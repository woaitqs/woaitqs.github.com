<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Source code about HashMap, hashmap 源码详细说明">
<meta name="keywords" content="源码, HashMap, 详细, 设计">
<meta property="og:type" content="article">
<meta property="og:title" content="Java HashMap 源码解析终极版">
<meta property="og:url" content="http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/index.html">
<meta property="og:site_name" content="Droid&#39;s blogs">
<meta property="og:description" content="Source code about HashMap, hashmap 源码详细说明">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-26T14:14:59.692Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java HashMap 源码解析终极版">
<meta name="twitter:description" content="Source code about HashMap, hashmap 源码详细说明">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Java HashMap 源码解析终极版</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Droid&#39;s blogs" type="application/atom+xml">
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2015/04/20/2015-04-20-read-source-code-about-volley/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2015/01/05/2015-01-05-how-to-solve-problem/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&text=Java HashMap 源码解析终极版"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&is_video=false&description=Java HashMap 源码解析终极版"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java HashMap 源码解析终极版&body=Check out this article: http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&name=Java HashMap 源码解析终极版&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序言"><span class="toc-number">1.</span> <span class="toc-text">序言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-是如何定义Map接口的"><span class="toc-number">2.</span> <span class="toc-text">JDK 是如何定义Map接口的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-基础单元"><span class="toc-number">3.</span> <span class="toc-text">HashMap 基础单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-如何避免冲突和解决冲突的"><span class="toc-number">4.</span> <span class="toc-text">HashMap 如何避免冲突和解决冲突的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-如何解决容量不足的问题"><span class="toc-number">5.</span> <span class="toc-text">HashMap 如何解决容量不足的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-是如何解决迭代问题"><span class="toc-number">6.</span> <span class="toc-text">HashMap 是如何解决迭代问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-是如何实现序列化接口的"><span class="toc-number">7.</span> <span class="toc-text">HashMap 是如何实现序列化接口的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文档信息"><span class="toc-number">8.</span> <span class="toc-text">文档信息</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    
    <h1 class="posttitle" itemprop="name headline">
        Java HashMap 源码解析终极版
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Droid's blogs</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2015-04-14T08:52:50.000Z" itemprop="datePublished">2015-04-14</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/program/">program</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/hashmap/">hashmap</a>, <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/program/">program</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>ConCurrentHashMap 是一个被忽视的Java Concurrent包下面的类，在满足并发的「安全性」，和「活跃性」的前提下，做到了与不考虑线程安全的 HashMap 同等效率. 作者是大名鼎鼎的<a href="http://en.wikipedia.org/wiki/Doug_Lea" target="_blank" rel="noopener">Doug Lea</a>，他老人家在Java 并发领域做的贡献，确实是我们的榜样。下篇文章，对ConCurrentHashMap做一个分析，希望这个代码中的闪光点，能够对各位读者产生启发。这里先介绍HashMap做的实现，便于后面我们理解2者的差异，以及[Doug Lea]完成的ConCurrentHashMap类具有那些惊为天人的地方。</p>
<hr>
<h2 id="JDK-是如何定义Map接口的"><a href="#JDK-是如何定义Map接口的" class="headerlink" title="JDK 是如何定义Map接口的"></a>JDK 是如何定义Map接口的</h2><p>在设计一个通用的模块和功能的时候，我们需要静下心来分析下根本需求是什么？根据这个需求来理清我们的思路。</p>
<p>Map，就是Key-Value对，通过Key可以快速找到对应的Value，核心的需求是Put和Get方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K,V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在实际的需求里面，虽然不同于Collection，但是一些基础功能和需求是共通的，所以需要额外地加上一些基础方法，比如<code>isEmpty()</code>,<code>size()</code>等。于是而后在原来的基础上添加了其他基础抽象，最后形成的接口大体可以如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这个时候，可能会有2个问题</p>
<p>1）为什么Map接口没有继承自Collection?</p>
<p>这个在JDK的问题里面所说的是Map，和Collection根本是两个东西，具体可以参考下面的引用</p>
<blockquote>
<p>This was by design. We feel that mappings are not collections and collections are not mappings. Thus, it makes little sense for Map to extend the Collection interface (or vice versa).<br>If a Map is a Collection, what are the elements? The only reasonable answer is “Key-value pairs”, but this provides a very limited (and not particularly useful) Map abstraction. You can’t ask what value a given key maps to, nor can you delete the entry for a given key without knowing what value it maps to.<br>Collection could be made to extend Map, but this raises the question: what are the keys? There’s no really satisfactory answer, and forcing one leads to an unnatural interface.<br>Maps can be viewed as Collections (of keys, values, or pairs), and this fact is reflected in the three “Collection view operations” on Maps (keySet, entrySet, and values). While it is, in principle, possible to view a List as a Map mapping indices to elements, this has the nasty property that deleting an element from the List changes the Key associated with every element before the deleted element. That’s why we don’t have a map view operation on Lists.</p>
</blockquote>
<p>Map可以用Collection来实现，但不一定意味着Map就一定是Collection，Collecton也不一定是Map。</p>
<p>2）为什么没有实现Iterator接口？</p>
<p>Map在定义上面就没有要求一定是可以迭代的，有人可能疑问用EntrySet来实现迭代啊？但是从设计的角度上去理解，如果用EntrySet的方式在接口里面申明Iterator接口，就意味着把内部的实现细节暴露出去了。所以宁愿提供 <code>entrySet()</code> 的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@code</span> Set&#125; containing all of the mappings in this &#123;<span class="doctag">@code</span> Map&#125;. Each mapping is</span></span><br><span class="line"><span class="comment"> * an instance of &#123;<span class="doctag">@link</span> Map.Entry&#125;. As the &#123;<span class="doctag">@code</span> Set&#125; is backed by this &#123;<span class="doctag">@code</span> Map&#125;,</span></span><br><span class="line"><span class="comment"> * changes in one will be reflected in the other.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a set of the mappings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HashMap-基础单元"><a href="#HashMap-基础单元" class="headerlink" title="HashMap 基础单元"></a>HashMap 基础单元</h2><p>HashMap作为我们经常用的类，几乎没有程序猿不熟悉Map的用法, 没有道理不去熟悉下HashMap的实现原理。</p>
<p>HashMap使用java提供的基础类型中的数组，用 <em>HashMapEntry&lt;K, V&gt;[] table</em> 来进行Key-Value键值对的存储。Hash需要完成的工作即是将Key通过Hash的算法，将Key hash到某一个小于数组长度的数值 <em>i</em> 上面，从而在这个位置 <em>i</em> 记录下对应的Value，亦即<code>table[i] = value</code>，这样调用者在调用<code>get(key)</code>方法时，先通过hash计算出i，调用<code>table[i]</code>可以迅速找到相应的Value，这是HashMap查询速度快的原因。</p>
<p>JDK首先构建了对基础单元的抽象-<code>HashMapEntry</code>，里面的核心成员变量如下代码，其中hash值一个用于缓存，便于进行比较，而next字段则实现了C++的指针，通过这个指针可以链式地找到下一位。这个链式结构的设计目的是为了解决Hash冲突的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HashMap-如何避免冲突和解决冲突的"><a href="#HashMap-如何避免冲突和解决冲突的" class="headerlink" title="HashMap 如何避免冲突和解决冲突的"></a>HashMap 如何避免冲突和解决冲突的</h2><p>当两个Key同时hash到一个值时，就会出现这样的冲突。这个冲突主要有2种解决方法。</p>
<ol>
<li>开放地址，亦即如果hash冲突，则在空闲的位置进行插入</li>
<li>hash复用，同一个hash值，链式地加入多个value</li>
</ol>
<p>HashMap 选择了第二种方式来解决冲突的问题，注意在 1.6 和 1.7 版本中，Java 对链式存储做了一些优化。如果链表的长度大于 8 个，就不再使用链表，而是采用红黑树，避免一些极限情况下的效率问题。</p>
<p>整个HashMap的核心部分是hash方法，我们先从最核心的方法看起，HashMap 是如何实现将hashCode值映射到table数组里面的索引里面的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> putValueForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">            preModify(e);</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No entry for (non-null) key is present; create one</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt; threshold) &#123;</span><br><span class="line">        tab = doubleCapacity();</span><br><span class="line">        index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addNewEntry(key, value, hash, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.secondaryHash(key)方法里面使用了</span></span><br><span class="line"><span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>在这里面可以看到Hash的代码主要是Wang/Jenkins hash方法，这个方法具有两个属性</p>
<ol>
<li>雪崩性（更改输入参数的任何一位，就将引起输出有一半以上的位发生变化）</li>
<li>可逆性（input ==&gt; hash ==&gt; inverse_hash ==&gt; input）</li>
</ol>
<p>Collections.secondaryHash能够使得hash过后的值的分布更加均匀，尽可能地避免冲突，<a href="http://burtleburtle.net/bob/hash/integer.html" target="_blank" rel="noopener">具体原理点连接</a>，注意这里的前提是table的长度为2的幂次方，从构造函数对capacity的改造可以看出来。<code>hash &amp; (tab.length - 1)</code> 当tab.length为2^n-1的时候，可以保证结果不大于tab.length。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MINIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = Collections.roundUpToPowerOfTwo(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    makeTable(capacity);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里举一个例子，如果现在Table的容量是16，如果最后的结果是 <strong>hash &amp; (16-1)</strong>，也就是 <strong>hash &amp; (00001111)</strong>。现在我们试着对hash值是31(00011111), 63(00111111),95(01011111)进行操作，理论上映射到的index值应该是不尽相同的，然而实际的情况确实如下的情形：</p>
<p>31=00011111 ==&amp; 00001111==&gt; 1111=15</p>
<p>63=00111111 ==&amp; 00001111==&gt; 1111=15</p>
<p>95=01011111 ==&amp; 00001111==&gt; 1111=15</p>
<p>因此Collections.secondaryHash需要解决的问题，就是避免上面的情况，效果见下面的例子：</p>
<p>31=00011111 ==secondaryHash==&gt; 00011110==&amp; 00001110==&gt; 14</p>
<p>63=00111111 ==secondaryHash==&gt; 00111100==&amp; 00001100==&gt; 12</p>
<p>95=01011111 ==secondaryHash==&gt; 01011010==&amp; 00001010==&gt; 10</p>
<hr>
<h2 id="HashMap-如何解决容量不足的问题"><a href="#HashMap-如何解决容量不足的问题" class="headerlink" title="HashMap 如何解决容量不足的问题"></a>HashMap 如何解决容量不足的问题</h2><p>前面解决了hash冲突的问题，那么现在如何解决容量不足的问题了。考虑这样的情况，如果用户大量地调用put方法，在这种情况下，如果容量不变，那么势必会出现大量的冲突，调用get方法时，可能需要很长长度的遍历才能得到答案，性能损失严重，因此，我们可以发现源码中有这样一种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size++ &gt; threshold) &#123;</span><br><span class="line">	tab = doubleCapacity();</span><br><span class="line">	index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK给出的方案是扩容，doubleCapacity()方法，比如原来容量为16，当现在的使用量大于 DEFAULT_LOAD_FACTOR X Capacity，下次直接把容量扩展到32.<br>这段代码注解说的是这整个类的精华，我们必须好好研究下.</p>
<blockquote>
<blockquote>
<p>Rehash the bucket using the minimum number of field writes, and this is the most subtle and delicate code in the class.</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Doubles the capacity of the hash table. Existing entries are placed in</span></span><br><span class="line"><span class="comment"> * the correct bucket on the enlarged table. If the current capacity is,</span></span><br><span class="line"><span class="comment"> * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which</span></span><br><span class="line"><span class="comment"> * will be new unless we were already at MAXIMUM_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> HashMapEntry&lt;K, V&gt;[] doubleCapacity() &#123;</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span>;</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCapacity; j++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Rehash the bucket using the minimum number of field writes.</span></span><br><span class="line"><span class="comment">         * This is the most subtle and delicate code in the class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMapEntry&lt;K, V&gt; e = oldTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> highBit = e.hash &amp; oldCapacity;</span><br><span class="line">        HashMapEntry&lt;K, V&gt; broken = <span class="keyword">null</span>;</span><br><span class="line">        newTable[j | highBit] = e;</span><br><span class="line">        <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; n = e.next; n != <span class="keyword">null</span>; e = n, n = n.next) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextHighBit = n.hash &amp; oldCapacity;</span><br><span class="line">            <span class="keyword">if</span> (nextHighBit != highBit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (broken == <span class="keyword">null</span>)</span><br><span class="line">                    newTable[j | nextHighBit] = n;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    broken.next = n;</span><br><span class="line">                broken = e;</span><br><span class="line">                highBit = nextHighBit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (broken != <span class="keyword">null</span>)</span><br><span class="line">            broken.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意其中这部分的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> highBit = e.hash &amp; oldCapacity;</span><br><span class="line">newTable[j | highBit] = e;</span><br></pre></td></tr></table></figure>

<p>我们现在来说明，oldCapacity假设为16(00010000), <strong>int highBit = e.hash &amp; oldCapacity</strong> 能够得到高位的值，因为低位全为0，经过与操作过后，低位一定是0。J 在这里是index，J 与 高位的值进行与操作过后，就能得到在扩容后面的新的index值。</p>
<p>设想一下，理论上我们得到的新的值应该是 <code>newValue = hash &amp; (newCapacity - 1)</code> ，与 <code>oldValue = hash &amp; (oldCapacity - 1)</code> 的区别仅在于高位上。 因此我们用 <code>J | highBit</code> 就可以得到新的index值。</p>
<hr>
<h2 id="HashMap-是如何解决迭代问题"><a href="#HashMap-是如何解决迭代问题" class="headerlink" title="HashMap 是如何解决迭代问题"></a>HashMap 是如何解决迭代问题</h2><p>首先HashMap提供了3种形式的迭代方法，分别是针对Entry，Key和Value的迭代器，这里实现的代码就比较简单，看下具体的例子就可以知道。实现方式主要是依赖于对HashEntity数组进行遍历即可实现。</p>
<p>问题在于如何保证迭代的时候，基于正确的输出，聪明的你一定看出来了，难度在于「多线程情况的处理」。在迭代的时候，外部可以通过调用put和remove的方法，来改变正在迭代的对象。但从设计之处，HashMap自身就不是线程安全的，因此HashMap在迭代的时候使用了一种Fast—Fail的实现方式，在HashIterator里面维持了一个 expectedModCount 的变量，在每次调用的时候如果发现 <code>ModCount != expectedModCount</code>，则抛出 ConcurrentModificationException 异常。但本身这种检验不能保证在发生错误的情况下，一定能抛出异常，所以我们需要在使用HashMap的时候，心里知道这是「非线程安全」的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashMapEntry&lt;K, V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (nextEntry == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    HashMapEntry&lt;K, V&gt; entryToReturn = nextEntry;</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">    HashMapEntry&lt;K, V&gt; next = entryToReturn.next;</span><br><span class="line">    <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) &#123;</span><br><span class="line">        next = tab[nextIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    nextEntry = next;</span><br><span class="line">    <span class="keyword">return</span> lastEntryReturned = entryToReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HashMap-是如何实现序列化接口的"><a href="#HashMap-是如何实现序列化接口的" class="headerlink" title="HashMap 是如何实现序列化接口的"></a>HashMap 是如何实现序列化接口的</h2><p>HashMap是实现了Serializable接口的，这种Hash的结构如何实现序列化？按照最朴素的想法，按照默认的实现即可，但是细想之下，一个16位的数组如果只存了一个数据，却要把16位的数组到序列化进去，这本身并不可取。于是HashMap 将其他数据申明为transient，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>

<p>避免这些常量参与到序列化的细节里面去，在另一方面重写 <strong>writeObject()</strong> 和 <strong>readObject()</strong> 方法，通过这样的方式来实现序列化，在代码里面添加了注释，便于大家理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Emulate loadFactor field for other implementations to read</span></span><br><span class="line">    ObjectOutputStream.PutField fields = stream.putFields();</span><br><span class="line">    fields.put(<span class="string">"loadFactor"</span>, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    stream.writeFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入table的容量</span></span><br><span class="line">    stream.writeInt(table.length); <span class="comment">// Capacity</span></span><br><span class="line">    <span class="comment">// 写入目前的Entry数量</span></span><br><span class="line">    stream.writeInt(size);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) &#123;</span><br><span class="line">    	<span class="comment">// 迭代地写入Key和Value</span></span><br><span class="line">        stream.writeObject(e.getKey());</span><br><span class="line">        stream.writeObject(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">    stream.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> capacity = stream.readInt();</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Capacity: "</span> + capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MINIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = Collections.roundUpToPowerOfTwo(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    makeTable(capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到size大小</span></span><br><span class="line">    <span class="keyword">int</span> size = stream.readInt();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(); <span class="comment">// Give subclass (LinkedHashMap) a chance to initialize itself</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) K key = (K) stream.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V val = (V) stream.readObject();</span><br><span class="line">        <span class="comment">// 构造函数里面，会计算hash放置到响应的地方</span></span><br><span class="line">        constructorPut(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li>
<li>发表日期：2018年11月10日</li>
<li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li>
<li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li>
</ul>
<hr>

  </div>
</article>


        <div id="vcomments"></div>
        <script>
            new Valine({
                el: '#vcomments',
                appId: 'TsNbG48vQyxT0tMC3xCbqg2B-MdYXbMMI',
                appKey: 'HNiBRfYlHGyIbgI65aR1Umgo'
            })
        </script>

        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#序言"><span class="toc-number">1.</span> <span class="toc-text">序言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-是如何定义Map接口的"><span class="toc-number">2.</span> <span class="toc-text">JDK 是如何定义Map接口的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-基础单元"><span class="toc-number">3.</span> <span class="toc-text">HashMap 基础单元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-如何避免冲突和解决冲突的"><span class="toc-number">4.</span> <span class="toc-text">HashMap 如何避免冲突和解决冲突的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-如何解决容量不足的问题"><span class="toc-number">5.</span> <span class="toc-text">HashMap 如何解决容量不足的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-是如何解决迭代问题"><span class="toc-number">6.</span> <span class="toc-text">HashMap 是如何解决迭代问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-是如何实现序列化接口的"><span class="toc-number">7.</span> <span class="toc-text">HashMap 是如何实现序列化接口的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文档信息"><span class="toc-number">8.</span> <span class="toc-text">文档信息</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&text=Java HashMap 源码解析终极版"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&is_video=false&description=Java HashMap 源码解析终极版"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java HashMap 源码解析终极版&body=Check out this article: http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&title=Java HashMap 源码解析终极版"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/&name=Java HashMap 源码解析终极版&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Qisen Tang
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?80435c13fc4c3f32d9ae5e4b1cea4b13";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->


</body>
</html>
