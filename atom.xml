<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Droid&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.woaitqs.cc/"/>
  <updated>2019-09-15T15:01:29.474Z</updated>
  <id>http://www.woaitqs.cc/</id>
  
  <author>
    <name>Qisen Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin 之弄懂 lambda</title>
    <link href="http://www.woaitqs.cc/2019/09/08/kotlin-lambda/"/>
    <id>http://www.woaitqs.cc/2019/09/08/kotlin-lambda/</id>
    <published>2019-09-08T07:27:19.000Z</published>
    <updated>2019-09-15T15:01:29.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数类型与函数实例化"><a href="#函数类型与函数实例化" class="headerlink" title="函数类型与函数实例化"></a>函数类型与函数实例化</h2><p>在kotlin中，函数与数据同样是一等公民，这意味着它们可以存储在变量与数据结构中、作为参数传递给其他<a href="~https://www.kotlincn.net/docs/reference/lambdas.html#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0~">高阶函数</a>以及从其他高阶函数返回，可以像操作任何其他非函数值一样操作函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square = &#123; item: <span class="built_in">Int</span> -&gt; item * item &#125;</span><br><span class="line">print(square(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>那么如果函数与数据同样是一等公民，那么数据拥有的<code>类型</code>，<code>实例</code>，函数是不是也同样拥有呢？答案是肯定的。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数也是拥有类型的，不过不同于<code>Int</code>、<code>String</code>这些大家耳熟能详的，而是以<code>(Type1,Type2,...)-&gt;Type</code>这种形式来定义的。例如上文中提到的square，它的类型就是<code>(Int)-&gt;Int</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; item: <span class="built_in">Int</span> -&gt;</span><br><span class="line">    item * item</span><br><span class="line">&#125;</span><br><span class="line">print(square(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>我们知道数据类型是可以继承的，以满足我们个性化的定制需求，函数类型也可以吗？当然！</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> : <span class="type"></span></span>(<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p1 * p1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数类型也可以定义在函数签名之中，我们看看这样的例子，参数action的类型就是函数类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWithInt</span><span class="params">(item: <span class="type">Int</span>, action: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> square: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; item: <span class="built_in">Int</span> -&gt; item * item &#125;</span><br><span class="line">    println(doWithInt(<span class="number">3</span>, square))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h3><p>那么函数有了类型，就一定有实例，就像Int可以有3，String可以有<code>HelloWorld</code>。我们来看看函数实例有什么样的要求。</p><p>首先已经声明的函数，都是具体的实例，无论是在class内部，还是属性等等。来看看例子，其中<code>::</code>表示创建对方法或者class的引用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(doWithInt(<span class="number">16</span>, ::square))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(item: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item * item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了前面的方式以为，还有另两种常用的实例化方法。一是lambda表达式、另一个是匿名函数。</p><p>先看看匿名函数的方法，匿名函数与普通函数的申明，区别仅仅在有没有方法名字上：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square = <span class="function"><span class="title">fun</span><span class="params">(item: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item * item</span><br><span class="line">&#125;</span><br><span class="line">print(doWithInt(<span class="number">16</span>,square))</span><br></pre></td></tr></table></figure><p>另一个就是本文的重点<code>lambda表达式</code>，其语法也很简单：</p><blockquote><p>{ param1 : Type1, param2 : Type2 , … -&gt; body }</p></blockquote><p>1.永远在大括号内。<br>2.参数两边不能有小括号。如果没有参数，可以留白，同时-&gt;也可以去掉。<br>3.方法体如果有多行，直接换行即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square = &#123; item:<span class="built_in">Int</span> -&gt;</span><br><span class="line">print(<span class="string">"HelloWorld"</span>)</span><br><span class="line">item*item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda表达式想对于匿名函数提供了更多便利的地方，大家尽量使用lambda表达式。</p><p>1.it代替单个参数<br>在很多情况下，参数可能只有一个，在lambda表达式中就可以用it来代替，从而简化语法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> square1:(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;</span><br><span class="line">item: <span class="built_in">Int</span> -&gt; item * item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> square:(<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;</span><br><span class="line">it * it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.lambda表达式作为最后一个参数</p><blockquote><p>在Kotlin中有一个约定：如果函数的最后一个参数是函数，那么作为相应参数传入的lambda表达式可以放在圆括号之外，这种语法也叫做拖尾lambda表达式。</p></blockquote><p>下面两种doWithInt的调用是等价的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWithInt</span><span class="params">(item: <span class="type">Int</span>, action: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>): <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> action(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doWithInt(<span class="number">25</span>, &#123; it * it &#125;)</span><br><span class="line">doWithInt(<span class="number">25</span>) &#123;</span><br><span class="line">    it * it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h2><p>前面我们讨论kotlin中的lambda很是欢畅，但到了Java这一侧就不那么愉快了。毕竟Java8中的lambda表达式只是闭包和invokeDynamic拼凑起来的四不像，Java8并没有函数这种类型，更别说kotlin对接的Java平台还只是Java7。</p><p>SAM = Single Abstract Method，即唯一抽象方法！</p><p>但兽人永不为奴，啊，呸，是kotlin无敌，针对SAM给我们提供了一个很甜的语法糖。我们来看看下面这个例子:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listener = View.OnClickListener &#123;</span><br><span class="line">it.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细分析一下，View.OnClickListener的官方函数是java的，申明如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Interface definition for a callback to be invoked when a view is clicked.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Called when a view has been clicked.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> v The view that was clicked.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">View.OnClickListener listener = newView.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(Viewv)</span> </span>&#123;</span><br><span class="line">v.setVisibility(View.GONE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Java这端需要的是OnClickListener匿名类的实例，而前面代码中提供的还只是lambda表达式。两者是不同的东西呀，那是怎么回事呢？这里需要提出一个SAM构造器的概念。</p><blockquote><p>FunctionInterfaceName { lambda_function }</p></blockquote><p>这是专门为Java提供的语法糖，用于将lambda表达式转换成相应的匿名类的实例。</p><p>同样，还可以在函数调用中使用SAM转换，由于类型是可以推断出来的，前面的FunctionInterfaceName甚至可以省略，下面两种写法是等价的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWithView</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    view.setOnClickListener(View.OnClickListener &#123;</span><br><span class="line">        it.visibility = View.GONE</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doWithView</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    view.setOnClickListener &#123;</span><br><span class="line">        it.visibility = View.GONE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们扩展一下，如果是kotlin会怎样呢？首先我们申明一个kotlin的接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KotlinInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSth</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们和前面Java一样，试图通过SAM构造器的方式，来创建匿名内部类的实例，情况会怎样？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this code will leads to compile error.</span></span><br><span class="line"><span class="comment">// var listener = KotlinInterface&#123; print("HelloWorld") &#125;</span></span><br></pre></td></tr></table></figure><p>这里居然报错了！！！</p><p><img src="/images/blog/kotlin-SAM-interface.png" alt="kotlin-sam-failed"></p><p>聪明的读者已经想到了，Kotlin中如果使用这种语法，是在调用KotlinInterface的构造函数，由于这是一个接口，并没有对应的构造函数，所以就报错了。那这里就奇怪了，Java中是SAM构造器语法，到Kotlin中这就是调用构造函数？答案确实是这样的，这是专门为Java提供的语法糖！</p><p>所以问题的关键是，为什么Kotlin要做这个限制呢？原因在于kotlin拥有更高阶的能力—高阶函数。对于Java而言，由于没有函数这个类型，对于SAM，只能是构造一个匿名对象，变相地绕过语言层面的限制。但kotlin不一样，其函数本身就是一等公民，没必要舍近求远。针对OnClickListener，Kotlin更愿意这样来申明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> onClicked:((view:View)-&gt;<span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="带Receiver的lambda"><a href="#带Receiver的lambda" class="headerlink" title="带Receiver的lambda"></a>带Receiver的lambda</h2><p>结合<a href="~https://woaitqs.cc/2019/09/08/kotlin-extension-method/~">前面的文章</a>，我们知道定义扩展函数，这个语法同样适用于lambda表达式。那么既然有了扩展函数，为什么还要给lambda也提供同样的能力呢？</p><p>假设，我们构建一个 json 的DSL (Domain Specific Language)，首先定义了一个生成键值对的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">warpKeyValue</span><span class="params">(tag: <span class="type">String</span>, handler: (<span class="type">StringBuilder</span>)</span></span> -&gt; <span class="built_in">Unit</span>): String &#123;</span><br><span class="line">        valbuilder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">"\"<span class="variable">$tag</span>\":"</span>)</span><br><span class="line">        handler(builder)</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(JsonBuilder().warpKeyValue(<span class="string">"key"</span>) &#123;</span><br><span class="line">        it.append(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// will output:</span></span><br><span class="line"><span class="comment">// "key":1</span></span><br></pre></td></tr></table></figure><p>这里关键在于it，对于DSL而言，如果每个地方都需要调用it的话，会很别扭。前面提到扩展函数，可以用this，或者省略，来调用Receiver的方法。如果我们给Receiver扩展一个lambda表达式，那就可以省略it了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">warpKeyValue</span><span class="params">(tag: <span class="type">String</span>, handler: <span class="type">StringBuilder</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): String &#123;</span><br><span class="line">        valbuilder = StringBuilder()</span><br><span class="line">        builder.append(<span class="string">"\"<span class="variable">$tag</span>\":"</span>)</span><br><span class="line">        builder.handler()</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(JsonBuilder().warpKeyValue(<span class="string">"key"</span>) &#123;</span><br><span class="line">        append(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// will output:</span></span><br><span class="line"><span class="comment">// "key":1</span></span><br></pre></td></tr></table></figure><p>那么为什么我们非得省略it这个了？是为了DSL更加美观，让使用者不必明白kotlin的相关语法细节。</p><p>我们来实现一个极简版本的jsonDSL（-<del>先不考虑JSON数组的情况</del>-），看看会变成什么样子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.StringBuilder</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">key</span><span class="params">(key: <span class="type">String</span>, action: <span class="type">JsonBuilder</span>.()</span></span> -&gt; <span class="built_in">Unit</span>): JsonBuilder &#123;</span><br><span class="line">        builder.append(<span class="string">"&#123;"</span>)</span><br><span class="line">        builder.append(<span class="string">"\"<span class="variable">$key</span>\":"</span>)</span><br><span class="line">        valvalueBuilder = JsonBuilder()</span><br><span class="line">        valueBuilder.action()</span><br><span class="line">        builder.append(valueBuilder.build())</span><br><span class="line">        builder.append(<span class="string">"&#125;"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">value</span><span class="params">(item: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (item) &#123;</span><br><span class="line">            isString -&gt; builder.append(<span class="string">"\"<span class="variable">$item</span>\""</span>)</span><br><span class="line">            isInt, <span class="built_in">Float</span>, <span class="built_in">Double</span>, <span class="built_in">Long</span> -&gt; builder.append(<span class="string">"<span class="variable">$item</span>"</span>)</span><br><span class="line">            isJsonBuilder -&gt; builder.append(item.build())</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"unsupported type"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">build</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = JsonBuilder()</span><br><span class="line">    builder.key(<span class="string">"Family"</span>) &#123;</span><br><span class="line">        key(<span class="string">"Parent"</span>) &#123;</span><br><span class="line">            key(<span class="string">"Son"</span>) &#123;</span><br><span class="line">                value(<span class="string">"Tom"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(builder.build())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会输出</p><p><img src="/images/blog/kotlin-jsonbuilder-output.png" alt="kotlin-sam-failed"></p><p>如果每次调用key，value方法都需要加上it，就达不到DSL的目的了。</p><p>这里给大家一个GitHub上，大神写的kotlinDSL的Demo，<a href="~https://github.com/rybalkinsd/kohttp~">GitHub-rybalkinsd/kohttp:Kotlin DSL http client</a>，语法还是相当舒服的。</p><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年09月15日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/atom.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      理解 kotlin 的lambda 比较晦涩的部分
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="kotlin" scheme="http://www.woaitqs.cc/tags/kotlin/"/>
    
      <category term="method" scheme="http://www.woaitqs.cc/tags/method/"/>
    
      <category term="lambda" scheme="http://www.woaitqs.cc/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>弄懂 kotlin 的扩展方法</title>
    <link href="http://www.woaitqs.cc/2019/09/08/kotlin-extension-method/"/>
    <id>http://www.woaitqs.cc/2019/09/08/kotlin-extension-method/</id>
    <published>2019-09-08T07:27:19.000Z</published>
    <updated>2019-09-08T07:41:09.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>扩展函数是 kotlin 的又一杀手锏功能，能够在不修改源码的基础上，扩展某些类的能力，方便开发。</p><p>例如这里演示了给 String 添加一个获取第一个元素的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">first</span><span class="params">()</span></span>: <span class="built_in">Char</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> NoSuchElementException(<span class="string">"String is empty"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello,World"</span>.first())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要额外注意的地方在于扩展函数的方法体中，是能够直接访问扩展对象 public 的变量的。例如上面的方法里面，我们也可以这么写:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">first</span><span class="params">()</span></span>: <span class="built_in">Char</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> NoSuchElementException(<span class="string">"String is empty"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>this</code> 可以在方法内，访问扩展对象，这里就是通过 this[0] 拿到第一个字符的。</p><hr><h2 id="Under-in-hood"><a href="#Under-in-hood" class="headerlink" title="Under in hood"></a>Under in hood</h2><p>看上去很厉害哈，但他的原理却非常简单。我们要时刻记住，kotlin JVM 是基于 JVM 开发的，kotlin 源码最后会变成字节码而后被运行。当遇到语法上不太懂的地方，直接反编译字节码，或者 Decompile 成 Java 方法，就能洞察里面的玄机。</p><p>我们将上述代码，Decompile 成 Java 后，就能发现里面的秘密。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">first</span><span class="params">(@NotNull String $<span class="keyword">this</span>$first)</span></span>&#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull($<span class="keyword">this</span>$first, <span class="string">"$this$first"</span>);</span><br><span class="line">   <span class="keyword">if</span> ($<span class="keyword">this</span>$first.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (Throwable)(<span class="keyword">new</span> NoSuchElementException(<span class="string">"String is empty"</span>));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> $<span class="keyword">this</span>$first.charAt(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是生成了一个 public static final 的方法呀，不过这个生成是 kotlin 提供的语法糖，帮我们完成的。看到这个代码，也解释了为什么在扩展对象方法内部，能够访问到扩展对象的 public 成员。</p><hr><h2 id="重载与多态"><a href="#重载与多态" class="headerlink" title="重载与多态"></a>重载与多态</h2><p>扩展方法能否被继承呢，或者重载呢？我们来看看例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="type">Animal</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Animal.<span class="title">desc</span><span class="params">()</span></span> = <span class="string">"Animal"</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Dog.<span class="title">desc</span><span class="params">()</span></span> = <span class="string">"Dog"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(Dog().desc())</span><br><span class="line">    <span class="keyword">var</span> animal: Animal = Dog()</span><br><span class="line">    println(animal.desc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Dog</span></span><br><span class="line"><span class="comment">// Animal</span></span><br></pre></td></tr></table></figure><p>如果扩展方法能够被重载，那么两次都应该输出 Dog，我们还是和前面方法一样，来看看真相。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">desc</span><span class="params">(@NotNull Animal $<span class="keyword">this</span>$desc)</span> </span>&#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull($<span class="keyword">this</span>$desc, <span class="string">"$this$desc"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"Animal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">desc</span><span class="params">(@NotNull Dog $<span class="keyword">this</span>$desc)</span> </span>&#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull($<span class="keyword">this</span>$desc, <span class="string">"$this$desc"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"Dog"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到实际生成了两个 desc 方法，里面的参数不动，所以这个方法的调用，只与扩展对象本身有关系，在编译时已经确定，不存在多态。</p><hr><h2 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h2><p>这是一个很神奇的设定，kotlin 并不能真的给扩展对象添加一个属性，而只是提供了一个语法糖，什么意思呢？我们具体看看下面这个例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> String.first: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> NoSuchElementException(“String <span class="keyword">is</span> empty”)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        println(“<span class="keyword">set</span> value to $value”)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    “Hello, World”.first = ‘G’</span><br><span class="line">    println(“Hello,World”.first)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们扩展了 kotlin 的属性，添加了一个 first。我们可以分别给这个所谓的 first 属性，注意是所谓的，添加 get 和 set 方法。然后我们可以通过 <code>=</code> 和 <code>.</code> 来调用 set 和 get 方法，就像 main 方法中那样。但实际上，最后并没有生成 first 属性，我们来看看反编译过后的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Char <span class="title">getFirst</span><span class="params">(@NotNull String $<span class="keyword">this</span>$first)</span> </span>&#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull($<span class="keyword">this</span>$first, <span class="string">"$this$first"</span>);</span><br><span class="line">   CharSequence var1 = (CharSequence)$<span class="keyword">this</span>$first;</span><br><span class="line">   <span class="keyword">boolean</span> var2 = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (var1.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (Throwable)(<span class="keyword">new</span> NoSuchElementException(<span class="string">"String is empty"</span>));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> $<span class="keyword">this</span>$first.charAt(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(@NotNull String $<span class="keyword">this</span>$first, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull($<span class="keyword">this</span>$first, <span class="string">"$this$first"</span>);</span><br><span class="line">   String var2 = <span class="string">"set value to "</span> + value;</span><br><span class="line">   <span class="keyword">boolean</span> var3 = <span class="keyword">false</span>;</span><br><span class="line">   System.out.println(var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，实际上只是添加了 setFirst 和 getFirst 两个方法，并没有实际的属性添加上去。这也是 kotlin 提供给我们的语法糖之一，糖要吃，但也要小心蛀牙哦！</p><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年09月08日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/atom.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      理解 kotlin 的扩展方法
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="kotlin" scheme="http://www.woaitqs.cc/tags/kotlin/"/>
    
      <category term="extension" scheme="http://www.woaitqs.cc/tags/extension/"/>
    
      <category term="method" scheme="http://www.woaitqs.cc/tags/method/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 类型系统原来如此简单</title>
    <link href="http://www.woaitqs.cc/2019/09/06/kotlin-class-hierarchy/"/>
    <id>http://www.woaitqs.cc/2019/09/06/kotlin-class-hierarchy/</id>
    <published>2019-09-06T07:24:47.000Z</published>
    <updated>2019-09-06T08:30:44.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h2><p>在学习 Kotlin 的过程中，对 Kotlin 的类型系统产生了好奇，Kotlin 是否存在类似于 Java 中 Object 的公共基类？Kotlin 中是否也有类似于 Java 基础类型这样的单独分支？在研究一番过后，博主发现相较于 Java，Kotlin 交出了更为满意的答案，而且出乎意外地简单，只需要遵循简单的规则，便能理解整个类型系统。</p><hr><h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>Any 等同于 Java 中的 Object 的概念，Any 在注释中这么写到:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The root of the Kotlin class hierarchy. Every Kotlin class has [Any] as a superclass.</span><br></pre></td></tr></table></figure><p>我们来简单验证下 Any 是一切的基类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(Fruit() <span class="keyword">is</span> Any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们新建了一个类，然后构造它的实例，看它是否为 Any，答案显而易见地为 <code>true</code>。</p><p>我们在看一些 kotlin 中的基础类型，也就是 Int、Double、Float、Byte 等等的父类是否也是 Any。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="number">3.233F</span> <span class="keyword">is</span> Any)</span><br><span class="line">println(<span class="number">2</span> <span class="keyword">is</span> Any)</span><br></pre></td></tr></table></figure><p>答案也是<code>true</code>。这里额外地解释下，Kotlin 并没有 Java 中基础类型和封装类型差异化处理，也没有<code>拆箱</code>和<code>装箱</code>的处理。基础类型就是基础类型，但它们也以<code>Any</code>作为父类。</p><hr><h2 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h2><p>再来看看 Unit 这个 Kotlin 中的特殊东西。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type with only one value: the `Unit` object. </span></span><br><span class="line"><span class="comment"> * This type corresponds to the `void` type in Java.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> <span class="built_in">Unit</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span> = <span class="string">"kotlin.Unit"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 kotlin 中每个函数一定是有返回值的。</p></blockquote><p>这里说明一下概念，也将会在后续的章节里面再次提到。kotlin 为了这个一定有返回值这个概念，做了很多工作，但好处是非常明显的，我们能够以统一的视角来看待 kotlin 的函数。</p><p>Unit 这个概念表征着什么都不做，但什么都不做确实也是一种返回值。如果我们不做任何声明，函数的返回值就是 Unit，表明我返回了一个什么都没做的东西。</p><p>我们来验证一下，声明一个空函数，然后打印它。(<del>在 Java 中会编译不过</del>)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">justReturn</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print(justReturn())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出了<code>kotlin.Unit</code>，证明了返回值就是 Unit。</p><p>那么这里有一个疑问，就是 Unit 和 Any 什么关系？我们通过 is 关键字来看看。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print(justReturn() <span class="keyword">is</span> Any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恩恩，Unit 也是 Any 的子类！</p><hr><h2 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h2><p>我们继续延展下<code>kotlin 中每个函数一定是有返回值的</code>这个概念。前面我们看的是正常返回的情况，那如果程序发生异常，也会有返回值吗？kotlin 对于这种情况，也是延续了一定有返回值这种概念。这个返回值叫做 - Nothing!</p><p>Nothing 意味着不可达，程序实际运行时不会产生任何一个 Nothing 类型对象，啥？！这怎么理解。kotlin 一旦发现返回了 Nothing，会保证后面的代码不再执行。</p><p>所以 Nothing 常用于 throw 这样异常退出的情况，这样后续的代码就不会被执行。我们看看 kotlin 中自身的例子。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Terminates the currently running process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status serves as a status code; by convention,</span></span><br><span class="line"><span class="comment"> * a nonzero status code indicates abnormal termination.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> This method never returns normally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">exitProcess</span><span class="params">(status: <span class="type">Int</span>)</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">    System.exit(status)</span><br><span class="line">    <span class="keyword">throw</span> RuntimeException(<span class="string">"System.exit returned normally, while it was supposed to halt JVM."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意啦，我们再看看 Nothing 在类型系统中的位置。Nothing 与 Any 相反，是一切类型的子类！也就是说 Nothing，是 Fruit、是 School、是 Money、也是 Any。Nothing 意味着不可达的状态，每一种类型都包含这种不可达的状态，因而这种状态 Nothing，是这些的子类。</p><p><img src="/images/blog/kotlin-nothing-hierarchy.png" alt="kotlin nothing"></p><p>注意上图中 Nothing 所处的位置。</p><hr><h2 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h2><p>kotlin 的一大杀手锏就是这个可空类型，一种类型后面加上?，这种类型就可以为空了。我们来看看引入可空类型过后，类型系统是怎样的。</p><ol><li>首先看看普通类和可空类型之间的关系。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    print(Fruit() <span class="keyword">is</span> Fruit?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>答案是<code>true</code>，这里很好理解，两者之间的区别在于是否可以为空，可以为空的自然而然是基类，不可为空的是可以为空下的一种派生。</p><ol start="2"><li>Any 是否有可空类型<br>kotlin 最让人欣赏的地方在于一个概念贯彻到底。Any 在 kotlin 中也是有可空类型的。感官上 Any? 是 Any 的父类，Any 是不可空类型的父类，所以 Any? 也是不可空类型的父类吗？答案就是这样的，我们来验证下。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    print(Fruit() is Any?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Unit 是否有可空类型<br>是的，Unit 也有空类型 <code>Unit?</code>。但这是一个难理解的概念，其本身包含了两个值 Unit 和 null。这是 kotlin 为了延续统一的概念，很少会有场景使用到，但咱们得清楚。</p></li><li><p>Nothing 是否有可空类型<br>Nothing 当然也有可空类型 <code>Nothing?</code>，其本身有且仅有一个值 <code>null</code>，也就是说其就是 null。Nothing 本身不可达，不会有任何一个实例，那就只能是 null 了。</p></li></ol><p>我们来验证一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">println(<span class="literal">null</span> <span class="keyword">is</span> <span class="built_in">Nothing</span>)</span><br><span class="line">println(<span class="literal">null</span> <span class="keyword">is</span> <span class="built_in">Nothing</span>?)</span><br><span class="line">println(<span class="literal">null</span> <span class="keyword">is</span> Any)</span><br><span class="line">println(<span class="literal">null</span> <span class="keyword">is</span> Any?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别是 false、true、false 和 true。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里借用下 natpryce 的图，大家看一下这张图，这就是 kotlin 的类型系统。<br><img src="/images/blog/kotlin-entire-hierarchy.png" alt="kotlin class hierachy"></p><p>咱们只需要理解一下几点，就完全弄明白 kotlin 类型系统。</p><ol><li>Any 和 Nothing 分别是所有对象的基类和子类。</li><li>可空类型是不可空类型的父类。</li></ol><p>当我们不清楚类型时，对照上面两个概念就能明白。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://natpryce.com/articles/000818.html" target="_blank" rel="noopener">Mistaeks I Hav Made: A Whirlwind Tour of the Kotlin Type Hierarchy</a></li><li><a href="https://proandroiddev.com/nothing-else-matters-in-kotlin-994a9ef106fc" target="_blank" rel="noopener">https://proandroiddev.com/nothing-else-matters-in-kotlin-994a9ef106fc</a> </li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年09月06日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/atom.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      理解 kotlin 的类型系统
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="unit" scheme="http://www.woaitqs.cc/tags/unit/"/>
    
      <category term="nothing" scheme="http://www.woaitqs.cc/tags/nothing/"/>
    
      <category term="kotlin" scheme="http://www.woaitqs.cc/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>浅谈移动端网络优化</title>
    <link href="http://www.woaitqs.cc/2019/09/02/improve-app-network/"/>
    <id>http://www.woaitqs.cc/2019/09/02/improve-app-network/</id>
    <published>2019-09-02T13:56:56.000Z</published>
    <updated>2019-09-02T14:05:50.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>对于内容消费性的 APP，从进入某个页面到该页面新内容显示出来，这阶段消耗的时间，是一个 APP 的生死线。如果这个时间相较于竞品差距太大，这将是毁灭性的事情，极有可能在争取用户中的赛场上处于下风。这篇文章，就试图从一个移动开发者的角度出发，分析一下整个内容加载过程，如何在不出错的情况下来优化和监控加载时间。</p><hr><h2 id="衡量"><a href="#衡量" class="headerlink" title="衡量"></a>衡量</h2><p>我们做一件优化的事情时，首先不是着急忙慌地寻找优化点，立马动笔写代码、改架构，而是得知道如何衡量这件事情。这样，我们不仅能帮我们整理思路，也能将优化的成果让更多人认可。</p><p>就「进入某个页面到该页面新内容显示」这个优化目标而言，我们先抛弃 Android、iOS、Web 的差异，缩减成「在移动设备上网络发起请求到接收数据」的时间，这样剔除掉组件加载、页面构建等等其他不确定因素。</p><p>那么首先映入我们脑海的，肯定是响应速度，同样的请求要是只用更少的时间就能拿回数据，那一定很棒！233333。所以我们有了第一个考虑维度 — ::速度::。</p><p>第二个需要考虑的点是::安全::，用户在请求数据时，往往会携带很多隐私信息(地区、设备、账号、等等)，如何保护这些信息不被窃取，也是另一个需要考虑的地方。</p><p>第三个需要考虑的点是::稳定::，这里主要由两部分组成。一是服务端的宕机率，很多大型 APP 的宕机率都要求小于 0.1%; 二是复杂网络环境下的策略，这里简单地举个例子，用户在偏远地区使用我们的 APP，信号不稳定，此时还能否正常返回数据？</p><p>这是三点，我考虑到的衡量内容加载的三个维度，这篇文章的后续内容也从这三个维度上，去思考如何优化内容加载。(<del>鄙人才疏学浅，肯定有考虑不周的地方，欢迎评论指出</del>)</p><hr><h2 id="解剖"><a href="#解剖" class="headerlink" title="解剖"></a>解剖</h2><p>我们知道如何衡量这件事情后，接下来就解剖「内容加载」，把其中发生的各个步骤拎出来，通过上述三个维度，来分析每个步骤。当然如果要详细地将每一个步骤说清楚，这就不是一篇文章的事情，因而在这里只能言简意赅地说说，最常见的路径下的各个步骤如下：</p><ol><li>DNS 查询 URL 对应 IP 地址。</li><li>与服务器建立连接（通常情况下为 TCP/IP 协议）。</li><li>根据应用层协议（HTTP/HTTPS）发送请求。</li><li>服务器响应请求，返回序列化的数据（Json/Proto）。</li><li>APP 反序列化数据，并予以呈现。</li></ol><p>更多更详细信息，可以参考<a href="https://github.com/alex/what-happens-when" target="_blank" rel="noopener">GitHub - alex/what-happens-when: An attempt to answer the age old interview question “What happens when you type google.com into your browser and press enter?”</a> ，详细地解答了「当你在浏览器中输入 google.com 并且按下回车之后发生了什么？」这个问题。</p><p>那现在开始，分别从上一小节提到的三个维度出发，分析每一个步骤。</p><hr><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>加载内容时，我们往往是通过 URL(统一资源定位符)，诸如<code>www.google.com</code>这样的链接。但这样的 URL 是不能直接使用的，就好像知道一个人的别名，但不能送货给它。因此我们访问 Google 时，通过某种查询服务得知到对应的 IP 地址，然后通过这个 IP 地址，我们才能建立连接请求，获取内容信息。这个服务叫做 Domain Name System，也就是大家常说的 DNS。</p><p>DNS 本身非常复杂，这里简要介绍流程。假设用户使用移动网络访问 APP 时，就会首先由网络服务商（移动网络就是电信、移动和联通等等运营商）分配一个本地域名服务器 LocalDNS，层层向上询问，最终通过权威域名服务器，返回一个 IP 地址。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>本地域名服务器 LocalDNS 是一个经常被人诟病的服务，我们具体看看都有些什么问题。</p><ol><li>安全<br>首先 LocalDNS 为了自身效率考虑，会做一些缓存，也就是将一些数据记录在本地，但这样会导致时效性问题。设想服务端在 12:00 上线了一个很棒的活动，并更改了 IP 地址和对应的解析协议，但由于 LocalDNS 的缓存导致过了一定时间后新的 IP 才生效，用户就不能及时地体验这个活动。</li></ol><p>上面这条还不是最严重的情况，LocalDNS 特别是一些小运营商，经常被人喷的是 DNS 劫持。可能为了某种创收，LocalDNS 缓存了部分页面，篡改了一下并添加了广告后，当用户请求 DNS 服务时，直接返回这个添加了广告的页面💥，用户就会相当反感！</p><ol start="2"><li>速度<br>不仅安全方面可能出现问题，速度也同样得不到保障。导致速度可能出现问题的本质原因是，本因作为参考的原始信息丢失，最终导致权威服务器没有返回一个最优 IP 地址，从而速度受到影响。下面罗列几种可能性：</li></ol><p>a. 小运营商直接将解析请求转给大运营商，权威 DNS 服务误以为这是大运营商的请求，从而没有返回服务器专门针对小运营商优化的 IP 地址。<br>b. NAT，更多信息参考<a href="https://zh.wikipedia.org/zh-hans/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">网络地址转换 - 维基百科，自由的百科全书</a>。当内网的某台设备想要与互联网上的服务器进行通信时，IP 地址可能会被更换，一旦做了网络地址的转换，权威的 DNS 服务器，就没办法通过这个信息作出最优解。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>优化的出发点就是尽量减少 DNS 请求，例如将大部分请求都放在同一个域名下。另外也已经有比较成熟的方案，既然 LocalDNS 坑，那我不陪你玩了，自己搞一套！</p><ol><li>HttpDns<br>HttpDns 就是应运而生的一套解决方案。APP 不再通过 LocalDNS 解析域名，而是通过服务端实现的服务，自己来查询域名对应的 IP 地址，这里查询的时候，是直接通过 IP 地址进行查询的。这样就略掉了域名解析，速度上面会有优化，直连服务器的做法也规避了 DNS 劫持导致的安全性问题。</li></ol><p>当然 HttpDns 能做的事情还有很多，例如客户端可以有一定的缓存策略，通过缓存来进一步优化时间。又比如服务端可以通过客户端提供的地区、服务商等等信息，做一些策略优化。</p><ol start="2"><li>CDN<br>我们查看快递的时候，经常会发现这样一种类型的 Case，例如我在南宁买了一个手机，那京东会首先查看南宁仓库有没有，没有继续就查询广西仓库（<del>不一定真实存在哈</del>），如果还没有就再查询京东物流总部。这样下来，快递的效率很高。某些服务提供商，就提供了这样的服务 — CDN(Content Delivery Network)，让对应的请求能够找到最优的<code>仓库</code>，降低网络拥塞，以最快的速度返回。</li></ol><p>CDN 通常会和 DNS 配合起来使用，所以这里单独拎出来说，运营同学修改 DNS 的设置，使得用户在访问资源时能够通过 CDN 来执行，<del>专业的事情交给专业的人来做</del>。由于 CDN 部署和生效需要一定的时间，一般用于分发静态资源。</p><hr><h2 id="TCP-HTTP"><a href="#TCP-HTTP" class="headerlink" title="TCP ~ HTTP"></a>TCP ~ HTTP</h2><p>再来看看拿到 IP 地址之后的事情，大多数情况下，App 在请求数据时，都是通过 TCP 协议来建立和关闭连接。只有在链接建立的基础之上，才能通过 Http/Https 或者其他应用层协议与服务端交互。由于 Http 的优化与 TCP 协议紧密相关，这里就放在一块讲。</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>TCP协议是面向连接的，可靠的流协议，但在移动网络下也有些水土不服，需要针对性地做一些优化。HTTP 本身也存在安全性等等问题，咱们具体看看。</p><ol><li><p>速度<br>TCP 协议在建立和关闭链接的时候，会涉及到三次握手和四次挥手，这是相对耗时的操作。但对于绝大多数 App 而言, 单次数据量都不大，但是次数很多，这会导致频繁地建立和关闭链接，导致用户体感上响应较慢。<br>HTTP/1.1 的时候，通过管道一次性发送多个请求，希望这样来提高效率。由于 TCP 协议的设定，每个请求必须按顺序进行，也就是说如果上一个请求阻塞住，后面的请求必须等待被阻塞的请求处理完毕过后再进行，这个问题被称为队头阻塞(<strong>Head-of-line blocking</strong>)。尽管在 HTTP/2 的时候，将数据拆分成若干个 Frame 发送，减少了阻塞的可能性，但只要是 TCP 协议，问题本质是在传输层，其实还是不能完全解决。</p></li><li><p>安全<br>前些年 iOS 强制要求开发者使用 HTTPS 协议的新闻，在 IT 圈被广泛讨论。原因就在于 HTTP 协议不能很好地保护用户隐私，隐患一直存在。因而即便在 Android 上，越来越多的 APP 也主动切换到更为安全的 HTTPS 上。</p></li><li><p>稳定<br>移动 APP 可能处于各种网络环境下，2G/3G/4G/校园网/公网 等等。Socket 的参数不能适用于所有情况，默认的参数可能表现很差。前面也提到，TCP 协议是有状态的，请求过去都需要回来的 ACK 包，但弱网环境下，包可能有很大的延迟，包越多就能耗时越久，用户体感越差。</p></li></ol><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><ol><li><p>链接复用<br>既然建立和关闭链接耗时，那就尽可能地复用它，这样就能优化速度。HTTP/1.x 可以设置为 <strong>keep-alive</strong>，或者接入 <strong>HTTP/2</strong>，<strong>HTTP/2</strong> 不仅能提供连接复用，也提供了诸多其他优化，例如 header 数据压缩，TLS 优化等等。</p></li><li><p>HTTPS<br>HTTP 协议存在安全隐患，那我们给他加上安全控制不就好了吗？HTTPS 也就诞生了，关于其如何加密数据的方式，也随着时间迭代了数个版本。有兴趣的同学，可以深入地了解下这段历史，能学到不少东西呢。</p></li><li><p>QUIC<br>既然 TCP 协议的机制决定速度不是最优的，那能不能用它的兄弟 UDP 来做一些事情？在 UDP 的基础之上，添加一些控制，在保证安全性的基础之上，尽可能地加快速度呢？<a href="https://www.chromium.org/quic" target="_blank" rel="noopener">QUIC，a multiplexed stream transport over UDP</a> 在 Google 的推动下就诞生了，相较于<strong>TCP + TLS + HTTP2</strong>的模式，有以下几点优势：</p></li></ol><ul><li>Dramatically reduced connection establishment time</li><li>Improved congestion control</li><li>Multiplexing without head of line blocking</li><li>Forward error correction</li><li>Connection migration</li></ul><hr><h2 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h2><p>终于到实际传输的数据了，这里核心的点，在于如何尽可能地减少包大小和如何保证数据安全上。罗列一下常见的优化方法:</p><ol><li>对于服务端定义的协议，查看有没有冗余的地方，优化数据结构。对于常见的公参字段做简化，例如 vc = version code，vn = version name 等等。</li><li>尝试使用<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protocol Buffers   |  Google Developers</a>，相较于其他格式而言，更小更快。</li><li>对于图片而言，可以使用<a href="https://developers.google.com/speed/webp/" target="_blank" rel="noopener">A new image format for the Web  |  WebP       |  Google Developers</a>。</li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>篇幅所下，很多知识都是点到为止，起到抛转引用的作用。最后阐述下，并没有万能的银弹，网络本身的复杂性就决定了没有统一的解决方案，各 APP 都需要针对自身的情况，去做一些特定的优化，来达到优化的目的，实践才是唯一的真理。<br>这里列出一些对外发布的优化实践例子，供大家参考:</p><ol><li><a href="https://tech.meituan.com/2017/03/17/shark-sdk.html" target="_blank" rel="noopener">美团点评移动网络优化实践 - 美团技术团队</a></li><li><a href="https://github.com/Tencent/mars/wiki" target="_blank" rel="noopener">Home · Tencent/mars Wiki · GitHub</a></li></ol><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://blog.cnbang.net/tech/3531/" target="_blank" rel="noopener">移动 APP 网络优化概述 «  bang’s blog</a></li><li><a href="https://hpbn.co/" target="_blank" rel="noopener">High Performance Browser Networking (O’Reilly)</a></li><li><a href="https://github.com/alex/what-happens-when" target="_blank" rel="noopener">GitHub - alex/what-happens-when: An attempt to answer the age old interview question “What happens when you type google.com into your browser and press enter?”</a></li><li><a href="https://tech.meituan.com/2017/03/17/shark-sdk.html" target="_blank" rel="noopener">https://tech.meituan.com/2017/03/17/shark-sdk.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html</a></li><li><a href="http://www.52im.net/thread-1003-1-1.html" target="_blank" rel="noopener">http://www.52im.net/thread-1003-1-1.html</a></li></ol><hr><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年09月02日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/atom.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      简要地介绍了移动端优化网络的常见技术
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="android" scheme="http://www.woaitqs.cc/tags/android/"/>
    
      <category term="network" scheme="http://www.woaitqs.cc/tags/network/"/>
    
      <category term="cdn" scheme="http://www.woaitqs.cc/tags/cdn/"/>
    
      <category term="dns" scheme="http://www.woaitqs.cc/tags/dns/"/>
    
      <category term="http" scheme="http://www.woaitqs.cc/tags/http/"/>
    
      <category term="tcp" scheme="http://www.woaitqs.cc/tags/tcp/"/>
    
      <category term="https" scheme="http://www.woaitqs.cc/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Android 最佳并发实践之线程篇</title>
    <link href="http://www.woaitqs.cc/2019/08/26/2019-08-26-java-concurency-part-2/"/>
    <id>http://www.woaitqs.cc/2019/08/26/2019-08-26-java-concurency-part-2/</id>
    <published>2019-08-26T12:32:07.000Z</published>
    <updated>2019-08-26T13:06:58.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在<a href="https://woaitqs.cc/2019/08/09/2019-08-09-java-concurency-part-1/" target="_blank" rel="noopener">上一篇文章</a>中，我们简要地了解了下 Android 开发实践中需要了解的基础知识，知道怎样的代码是并发安全的。现在我们再来看看并发中的具体执行者 – 线程又是怎样的？有什么样的知识需要了解，它们是如何合作来进行同步的？</p><p>线程作为 CPU 最小的执行单元，通常情况下的 Android 并发是指多线程环境下进行并发，那么我们首先了解下线程。CPU 负责调度线程资源，通过各种调度机制，雨露均沾，将每个线程都运转起来。但既然有调度机制，那每一个线程不可能一直在运行，这样线程就有了状态，通过对这些状态的分析，我们就能从另一个角度了解线程是如何运行的。</p><p><img src="/images/blog/thread-state.jpg" alt="java thread state"></p><p>上图就是 thread 可能处于的状态，看上去很复杂，但我们可以逐步突破，一个状态一个状态地分析。</p><p>再进行详细的讲解之前，先说明一下本文所讲的线程状态都是基于<code>虚拟机</code>的，而非<code>操作系统</code>的。由于 Microsoft、Linux、Unix 等等，都有自己的线程模型，具体实现的时候都各自维护着不同的状态信息，Java 是一个跨平台的语言，因而得有虚拟机这一层来屏蔽不同操作系统之间的差异。本文所研究的正是，虚拟机这一层的线程状态，而非操作系统的线程状态！</p><p>我们通过以下的代码<code>thread.getState()</code>，来判断当前线程所处于的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dumpThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">  Log.d(<span class="string">"thread"</span>, </span><br><span class="line">String.format(</span><br><span class="line"><span class="string">"info:%s, state:%s"</span>, thread, thread.getState()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机定义了6种线程状态，咱们分别看看。</p><ol><li>NEW</li><li>RUNNABLE</li><li>BLOCKED</li><li>WAITING</li><li>TIMED_WAITING</li><li>TERMINATED</li></ol><h2 id="New"><a href="#New" class="headerlink" title="New"></a>New</h2><p>这个状态最简单，但我们 new 出一个线程对象，并没有调用 start 方法时，它就处于 New 状态，例如下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.d(<span class="string">"Thread"</span>, <span class="string">"I'm running now."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="string">"ThreadStateDemo"</span>);</span><br><span class="line"></span><br><span class="line">dumpThread(thread);</span><br></pre></td></tr></table></figure><p>此时对应的输出是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/thread: info:Thread[ThreadStateDemo,5,main], state:NEW</span><br></pre></td></tr></table></figure><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.start();</span><br><span class="line">dumpThread(thread);</span><br></pre></td></tr></table></figure><p>此时的日志输出是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D/thread: info:Thread[ThreadStateDemo,<span class="number">5</span>,main], state:RUNNABLE</span><br></pre></td></tr></table></figure><p>在调用 start 方法过后，线程就会进入到 Runnable 状态。但此时并不会立刻执行，而是进入到 <code>Ready To Run</code>的子状态中，当获取到线程资源的时候，线程才会切换到 <code>Running</code>状态。而 CPU 在执行一段时间的线程过后，也会因为用完时间片，而再次切换回<code>Ready To Run</code>，周而复始地这么运转。</p><p>RUNNABLE 的注释如下</p><blockquote><p>Thread state for a runnable thread. A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.</p></blockquote><p>此时我们是无法通过前面的代码来区分出，线程是 Running 状态，还是 Ready To Run 状态。</p><p>因为两个状态的切换，映射到了操作系统底层的线程上，把调度委托给了操作系统，我们在虚拟机层面看到的状态实质是对底层状态的映射及包装。JVM 本身没有做什么实质的调度，把底层的 <code>Ready To Run</code> 及 <code>Running</code> 状态映射上来也没多大意义，因此，统一成为 Runnable 状态是不错的选择。</p><p>这里还需要特别注意的地方是 I/O 操作，通常情况下 I/O 操作的耗时程度是远大于一个时间分片的，因而正常情况下在执行 I/O 操作时，都会暂时挂起 CPU，等待 I/O 操作执行完毕过后的中断信号，而恢复运行。那么在这种情况下，对于虚拟机的线程状态而言，还是处于 Runnable 吗？答案是肯定的，从虚拟机的角度上看，该线程就是在执行 I/O 操作，才不会关心要怎样执行，要怎么处理中断，那都是操作系统的事情。</p><p><img src="/images/blog/thread-runnable.png" alt="图片来自肖国栋的博客"></p><h2 id="Blocked"><a href="#Blocked" class="headerlink" title="Blocked"></a>Blocked</h2><p><del>划重点，这是考试必考内容。</del><br>这部分的线程状态，就与同步有着巨大的关系了，我们来具体了解下 Blocked 状态是怎样的。</p><blockquote><p>Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling {@link Object#wait() Object.wait}.</p></blockquote><p>从这段代码中，我们能够分析出两种情况。</p><ol><li>需要等待监视器锁去进入一个同步块时。</li><li>在一个同步块中，执行 <code>Object.wait</code> 过后，再次等待进入同步块时。</li></ol><h3 id="Blocked-enter-a-synchronized-block"><a href="#Blocked-enter-a-synchronized-block" class="headerlink" title="Blocked - enter a synchronized block"></a>Blocked - enter a synchronized block</h3><p>咱们先看第一种情况，<code>需要等待监视器锁去进入一个同步块时</code>。根据第一篇文章中 synchronized 的原理，多个线程进入同一个代码块时，没有持有锁的线程就必须等待，这里说的就是这种情况。</p><p>我们从具体的代码入手，分析下这种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (MainActivity.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Thread threadA = <span class="keyword">new</span> Thread(runnable, <span class="string">"thread-A"</span>);</span><br><span class="line">  Thread threadB = <span class="keyword">new</span> Thread(runnable, <span class="string">"thread-B"</span>);</span><br><span class="line">  Thread threadC = <span class="keyword">new</span> Thread(runnable, <span class="string">"thread-C"</span>);</span><br><span class="line">  threadA.start();</span><br><span class="line">  threadB.start();</span><br><span class="line">  threadC.start();</span><br><span class="line">  dumpThread(threadA);</span><br><span class="line">  dumpThread(threadB);</span><br><span class="line">  dumpThread(threadC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/thread: info:Thread[thread-A,5,main], state:TIMED_WAITING</span><br><span class="line">D/thread: info:Thread[thread-B,5,main], state:BLOCKED</span><br><span class="line">D/thread: info:Thread[thread-C,5,main], state:BLOCKED</span><br></pre></td></tr></table></figure><p>B 和 C 线程都因为没有抢到锁，而不得不等待，此时的用户状态正是 Blocked。</p><p>这里引入一个概念，Entry Set，道上人也尊称为锁池。当多个线程竞争锁时，会抢占到资源的线程，会被加入到锁池中。当锁释放时，锁池中的任意一个线程会被唤醒，与其他活跃线程再次抢占锁。如果成功占用锁，就从锁池中移除，否则就老老实实呆着锁池中。</p><h3 id="Blocked-reenter-a-synchronized-block-after-object-wait"><a href="#Blocked-reenter-a-synchronized-block-after-object-wait" class="headerlink" title="Blocked - reenter a synchronized block after object.wait"></a>Blocked - reenter a synchronized block after object.wait</h3><p>第二种情况，听上去非常拗口，一要再次进入同步块，二要调用 wait 方法。这里必须要了解两个额外的概念，wait 和 等待池。</p><p>我们设想这样一种场景，大家都在排队使用咖啡机喝咖啡。最开始的时候，大家都依次占有咖啡机(🔐)，弄好咖啡过后再释放掉，队伍也严谨地往前步进；但此时，一个运气不好的小姐姐，在使用咖啡机的时候，发现咖啡机里面的牛奶🥛不够了，此时就要引申出<code>wait</code>这一哲学操作了。小姐姐此时只能暂时放弃咖啡机(🔐), 在一旁等待。工作人员添加牛奶🥛过后，调用 notify/notifyAll 过后，再进行排队弄咖啡。</p><p>wait 的语义是暂时放弃锁，等待其他线程调用 notify/notifyAll。要注意到 wait 方法的调用一定是在同步块中，wait 是要放弃锁的，只能在持有锁过后才会释放掉。调用 wait 操作过后，线程会进入<code>等待池</code>中，其他线程调用 notify/notifyAll，通知任意一个或者全部等待池中的线程，去和锁池和其他活跃线程竞争锁。</p><p>在 wait 过后，再去竞争线程资源时，此时的状态也是 Blocked。</p><p>以上就是两种 Blocked 状态的情况，大家也多注意线程在 Blocked 上如何处理的，也对我们如何写同步代码提供帮助。</p><h2 id="Waiting"><a href="#Waiting" class="headerlink" title="Waiting"></a>Waiting</h2><p>再来看看 Waiting 状态，从官方文档入手。</p><blockquote><p>Thread state for a waiting thread. A thread is in the waiting state due to calling one of the following methods:</p><ol><li>{@link Object#wait() Object.wait} with no timeout</li><li>{@link Thread#join() Thread.join} with no timeout</li><li>{@link LockSupport#park() LockSupport.park}</li></ol></blockquote><h3 id="no-timeout-wait"><a href="#no-timeout-wait" class="headerlink" title="no timeout wait"></a>no timeout wait</h3><p>在上一个状态的讲解中，提到了 wait 的操作，当一个线程调用了 wait，并且在等待 notify/notifyAll 的过程中，该线程所处的状态就是 Waiting。如果读者是服务端相关的人员，可能会遇到这样一个面试题，就是用 wait/notify 来实现一个生产者-消费者模式。本文主要是将并发相关的知识，大家有兴趣具体去了解下。</p><h3 id="no-timeout-join"><a href="#no-timeout-join" class="headerlink" title="no timeout join"></a>no timeout join</h3><p>join 就是等待另一个线程结束，如果查看源码的话，就会发现其可以当做隐式的 wait/notify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            lock.wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LockSupport-park"><a href="#LockSupport-park" class="headerlink" title="LockSupport.park"></a>LockSupport.park</h3><p>LookSupport 是 JDK 1.6 开始引入的同步工具，是线程的阻塞原语，用来阻塞线程和唤醒线程。我们可以利用 LookSupport 来实现自己的同步工具。</p><h2 id="Timed-Waiting"><a href="#Timed-Waiting" class="headerlink" title="Timed_Waiting"></a>Timed_Waiting</h2><blockquote><p>A thread that is waiting for another thread to perform an action for up to a specified waiting time is in this state.</p></blockquote><p>TIMED_WAITING 与 WAITING 主要区别在于时效上面，当我们 wait，join，sleep 操作带有时效时，就会进入 TIMED_WAITING 状态。</p><p>需要重点指出的是 sleep、yield 不带有任何同步语义。什么意思呢，就是 sleep 之前持有锁，那sleep的时候还持有锁；如果不持有，sleep的时候依然不持有。与同步没有任何关系。</p><p>Waiting、Timed-Waiting 与 Blocked 状态，对于 JVM 层面，区别主要在于是否为主动的。主动地等待，就是 Waiting、Timed-Waiting，被动等待锁就是 Blocked 状态。</p><h2 id="Terminated"><a href="#Terminated" class="headerlink" title="Terminated"></a>Terminated</h2><p>这个就相对简单些了，但线程执行结束过后，就进入了 TERMINATED 状态。且无法再恢复到其他状态中去了。</p><h2 id="Android-中查看线程状态"><a href="#Android-中查看线程状态" class="headerlink" title="Android 中查看线程状态"></a>Android 中查看线程状态</h2><p>学以致用，接下来介绍两种常见的方法来查看线程状态。当我们遇到同步问题时，可以通过对线程状态的分析，发现症结所在。</p><ol><li>Android Debugger</li></ol><p>在 Debugger 中点击 <code>Get thread dump</code> 的按钮，这样可以查看快照时的线程状态。</p><p>点击每个线程，可有详细的信息，例如：<br>“main@7067” prio=5 tid=0x2 nid=NA runnable</p><p>其中 prio 是指优先级、tid是线程id，nid是native线程id</p><p><img src="/images/blog/android-debugger-thread.png" alt="android debugger thread"></p><ol start="2"><li>anr dump</li></ol><p>还有一种技巧是利用 Android 的 ANR 机制，强制应用发生 ANR，这样再 dump 出 anr 日志，即可查看各线程状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell kill -3 [pid]</span><br></pre></td></tr></table></figure><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年08月26日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/atom.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      这篇文章是最佳并发实践的第二篇，重点介绍JVM的线程原理
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="concurrency" scheme="http://www.woaitqs.cc/tags/concurrency/"/>
    
      <category term="volatile" scheme="http://www.woaitqs.cc/tags/volatile/"/>
    
      <category term="synchronized" scheme="http://www.woaitqs.cc/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Android 最佳并发实践之基础篇</title>
    <link href="http://www.woaitqs.cc/2019/08/09/2019-08-09-java-concurency-part-1/"/>
    <id>http://www.woaitqs.cc/2019/08/09/2019-08-09-java-concurency-part-1/</id>
    <published>2019-08-09T08:54:39.000Z</published>
    <updated>2019-09-06T07:25:04.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>虽然移动开发，对并发同步要求，没有服务端那么重，但我在很多项目代码中，都看到不合理的用法，或者没有达到设想的情况。这篇文章重点分析下，移动开发开发中应该了解的并发知识。</p><hr><h2 id="同步的三个问题"><a href="#同步的三个问题" class="headerlink" title="同步的三个问题"></a>同步的三个问题</h2><blockquote><p>多个线程访问某个类时，不管运行时环境采用何种 <strong>调度方式</strong> 或者这些线程将如何交替执行，并且在主调代码中 <strong>不需要任何额外的同步或协同</strong>，这个类都能表现出<strong>正确的行为</strong>，那么这个类就是线程安全的。</p></blockquote><p>为了达成这种目的，我们需要在三个方面上进行考核。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一段代码要么不执行，要么执行就不能被打断地执行到底，这样不可分割的特性，称之为原子性。这种特性非常关键，我们来举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>如果上述的赋值语句不是原子性的，而是分高低位进行赋值，那很有可能在<code>给高位赋值后且还没来得及给低位赋值</code>这个过程中，另一个线程进行取值，此时很可能得到一个错误的值。</p><p>当在执行一个满足原子性的操作时，我们不用担心，会有多个线程同时访问导致错误的结果。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>我们不仅希望防止某个线程在使用某个对象状态时另一个线程在同时修改这种状态，而且希望确保<em>当一个线程修改对象状态过后，其他线程能够看到发生的状态变化</em>，这也就是<code>可见性</code>。</p><p>可见性是一种复杂的属性，往往会和我们的直接有所违背。设想，我们往某个变量写入了值，然后在其他线程读取该值时，理论上应该总能得到最新的值，然而事实上并不是这样。</p><p>为了方便大家理解可见性这个概念，需要简要地介绍下 多处理器体系架构下的内存模型。</p><blockquote><p>在共享内存的多处理器体系架构中，每个处理器都拥有自己的缓存，并定期地与主内存进行协调。在不同的处理器架构中提供了不同级别的缓存一致性，其中一部分甚至只提供最小的保证，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。操作系统、编译器以及运行时，需要弥合这种在硬件能力与线程安全需求之间的差异。</p></blockquote><p><img src="/images/blog/jmm.png" alt="java memory model"></p><p>主内存：主内存被多个线程共享，对于一个共享变量而言，这里存放着其本身。<br>工作内存：出于性能的考虑，每个线程有自己的工作内存，是名副其实的副本。</p><p>Java 内存模型规定了 8 种支持的原子操作，可以先粗略看看。</p><p><img src="/images/blog/java-atomic-op.png" alt="jmm 原子操作"></p><p>可以看到一个对象在主内存和工作内存中，并不能保证每个时刻值都一样，而是通过多个复合原子操作来保证一致性。</p><p>于是就有多种可能性，例如<code>多级缓存</code>、<code>处理器本地缓存的值对其他处理器不可见</code>等等因素，导致不能立即看到正确的值。</p><p>例如全局变量 var 值为 0，A 线程将全局变量 var 设置为3，B 线程打印这个值。即便 A 线程先开始，也不能保证 B 线程一定能打印出 3 。</p><p>截止目前，大家还是对可见性缺乏具像的认识，我写了下面的一个例子，大家可以从 Console 的输出中看到并没有 <code>Work is done</code>的输出，也就说 stopFlag 即便已经修改了值，在 <code>thread</code>并没有看见！</p><p><img src="/images/blog/visiblity.png" alt="visibility code"></p><p>我们一定要注意可见性这个问题，否则会像陈永仁一样，陷入了<code>三年只有又三年</code>的无间地狱里面，等不到结束信号！</p><p><img src="/images/blog/wujiandao.jpg" alt="无间道"></p><p>P.S. 在后续的研究中发现，上述的测试代码有考虑不周的地方。在实际执行的时候，上述的代码会被 JIT 优化成类似于 <code>if(stopFlag){while(true){}}</code> 这样的形式！显然这违背我们写代码进行测试的初衷。大家如果有测试可见性更好的方法，欢迎指定迷津。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>代码的实际执行顺序要与申明的顺序一致。这听上去是很理所当然的，然而实际在运行时并不一定符合我们的预期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">② <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">③ a ++;</span><br><span class="line">④ b --;</span><br></pre></td></tr></table></figure><p>我们看看上面这段代码，理想情况下执行的顺序应该是①②③④，但实际的执行顺序可能是②①③④。那有没有可能③④在①②之前执行呢，不可能！这里需要引入一个<strong>重排序</strong>的概念，来帮助我们分析上面的顺序问题。</p><blockquote><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p></blockquote><p>重排序并不是随便排序的，而是有一定规则的，JMM（Java Memory Model）遵循 Happens-Before 准则。我们在实际开发中，只要按照 Happens-Before 来，代码就没什么问题。</p><blockquote><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ol></blockquote><p>我们从 Double-Check 来看看上面这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，就有可能出现由重排序导致的问题。<code>instance = new Singleton();</code> 这句话，实际执行的时候，有多个步骤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">① // 分配空间</span><br><span class="line">② // 初始化</span><br><span class="line">③ // 给引用赋值</span><br></pre></td></tr></table></figure><p>假如②与③进行了重排序，并且一个线程执行了③，还未执行②，而此时另一个线程执行到了第一个 <code>if (instance == null) {</code>，那么该线程就会返回一个未初始化完毕的对象，从而导致意想不到的问题。</p><h3 id="安全性总结"><a href="#安全性总结" class="headerlink" title="安全性总结"></a>安全性总结</h3><p>光是想要在多线程环境下达到安全性的目的，就得考虑原子性、可见性和有序性。但这还没完，想要运行得好，还得等待性能、活性、死锁其他方面的问题，路漫漫其修远兮。</p><p>注：活性失败，是指某个线程始终获取不到资源，活活饿死。</p><hr><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>在了解可见性和有序性过后，就相对好理解 Volatile 这个关键字了。Volatile 是 Java 提供的轻量级同步机制，相较于 synchronized 需要进行系统调用而言轻便了不少。</p><p>我们看看 volatile 是如何帮助我们的。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>首先我们需要了解下内存屏障这个概念。</p><blockquote><p>内存屏障是硬件层的概念，分为 readBarrier 和 writeBarrier。一般有两个作用，一是屏蔽两边的指令重排序，另一个是强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。</p></blockquote><p>对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；<br>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p><p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。</p><ol><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ol><p>对于每一个被 volatile 修饰的变量，JVM 会自动地做两件事情。<br>1.在每个volatile写操作前插入<strong>StoreStore</strong>屏障，在写操作后插入<strong>StoreLoad</strong>屏障。<br>2.在每个volatile读操作前插入<strong>LoadLoad</strong>屏障，在读操作后插入<strong>LoadStore</strong>屏障。</p><p>由此，我们可以推断出，被 volatile 关键字修饰的变量有两个特点：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。</p><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>我们来分析下第一个特点，volatile 是如何保证可见性的。回到前面可能一直会陷入死循环的代码，如果变量前加入 volatile，死循环就会结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopFlag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>volatile 会使得汇编代码中，多出一道 lock 前缀指令，相当于一个内存屏障（内存栅栏），它提供了三方面的保证：<br>1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>2）它会强制将对缓存的修改操作立即写入主存；<br>3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p>所以，当 main 函数的执行线程，将 stopFlag 置为 true 的时候，会让另一个线程缓存中的值失效，从而执行到判断代码时，会从主内存里更新，拿到最新的值结束循环。</p><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>另一个特点就是禁止重排序，以 volatile 修饰属性的读/写操作代码行为 <strong>分界线</strong>，读/写操作前面的代码不许排序到后面，后面同理不许排序到前面。</p><p>稍微有点拗口，我们来看看实际的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">① x = <span class="number">1</span>;</span><br><span class="line">② y = <span class="number">2</span>;</span><br><span class="line">③ flag = <span class="keyword">true</span>; <span class="comment">// flag is volatile variable</span></span><br><span class="line">④ x = <span class="number">3</span>;</span><br><span class="line">⑤ y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>根据前面提到的知识，①②顺序可能颠倒，④⑤顺序可能颠倒，但它们一定在 ③ 之前和之后，从而来保证有序性。再回到 double-check 的例子，volatile 保证了给 Instance 赋值时，初始化工作已经执行完毕，因而不会有问题。</p><p>我们再来看看《Java 并发实践》中的经典例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context = loadContext();</span><br><span class="line">contextReady = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!contextReady) &#123;</span><br><span class="line"><span class="comment">// keep waiting.</span></span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithContext(context);</span><br></pre></td></tr></table></figure><p>如果这里发生了指令重拍，那么有这样的一种情况，会引发异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 线程以这样一种顺序来执行</span></span><br><span class="line">contextReady = <span class="keyword">true</span>;</span><br><span class="line">context = loadContext();</span><br></pre></td></tr></table></figure><p>另一个 B 线程在执行的时候，发现 contextReady 已经为 true，但此时 context 并未构建完毕，从而在 doSomethingWithContext 发生错误。</p><p>如果 ContextReady 是 volatile 变量，由于前后的内存屏障，前面的代码不会发生重排序，因而代码是可以 work 的。</p><p>P.S. 需要特别指出的是，volatile 并不能保证原子性，类似于 <code>i++</code> 这样的复合操作，使用 volatile 是不能保证线程安全的。</p><hr><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>我们在写同步代码的时候，最常用到的关键字就是 <code>synchronized</code>。我们有必要了解清楚 synchronized ，导致是怎么帮我们完成同步的。</p><h3 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h3><p>在学习操作系统的时候，是否还记得 <code>Mutex(互斥锁)</code>? </p><blockquote><p>用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。</p></blockquote><p><img src="/images/blog/system-mutex.jpg" alt="system mutex"></p><p>1) 申请 mutex<br>2) 如果成功，则持有该 mutex<br>3) 如果失败，则进行spin自旋. spin的过程就是在线等待mutex, 不断发起mutex gets, 直到获得mutex或者达到spin_count限制为止<br>4) 依据工作模式的不同选择yiled还是sleep<br>5) 若达到sleep限制或者被主动唤醒或者完成yield, 则重复(1)~(4)步，直到获得为止。</p><p>Java 所有的同步，都是和对象有关系，每个对象都对应于一个可称为互斥锁的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。这也是为什么 wait 和 notify/notifyAll 是 Object 的属性方法。</p><p>JVM 本身不具有同步能力，同步操作都是依赖于操作系统，这也就意味着是 <code>System Call</code>，需要在用户态和核心态之间切换，是重量级操作。synchronized 本身是 Java 提供的语法糖，封装了 Mutex 的相关调用（在后面会详细说明，synchronized 自身的优化）。</p><p><img src="/images/blog/synchronized_block_code.png" alt="synchronized block code"></p><p>还是以前面那段 Double-Check 作为例子，反编译 class 文件后，得到上面的代码。代码块同步是使用 monitorenter 和 monitorexit 指令实现的，monitorenter 指令是在编译后插入到同步代码块的开始位置，而 monitorexit 是插入到方法结束处和异常处。</p><p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要去尝试获取对象的锁，如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1；相应地，在执行 monitorexit 指令时会将锁计数器减1，当计数器被减到0时，锁就释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们变化下 Double-Check 的代码，直接在方法上申明 synchronized，class 文件会相应地变化。没有了 monitorenter/exit 相关的代码，而是多了一个 ACC_SYNCHRONIZED 的标记。这个标记与 monitorenter/exit 类似，当进入某个方法体时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取 monitor，获取成功之后才能执行方法体，方法执行完后再释放 monitor。</p><p><img src="/images/blog/synchronized-method-code.png" alt="synchronized method code"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><img src="/images/blog/synchronized-usage.png" alt="synchronized usage"></p><p>synchronized 的用法比较简单，无非是需要知道锁实例对象还是类对象的区别。</p><p>接下来，问大家几个问题，大家可以在心里面想一下输出的结果是什么，如果大家心里对这个有谱，那就是完全掌握其用法了。</p><h4 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h4><p><img src="/images/blog/sync-round1.png" alt="round 1"></p><h4 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h4><p><img src="/images/blog/sync-round2.png" alt="round 2"></p><h4 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a>Round 3</h4><p><img src="/images/blog/sync-round3.png" alt="round 3"></p><h4 id="Round-4"><a href="#Round-4" class="headerlink" title="Round 4"></a>Round 4</h4><p><img src="/images/blog/sync-round4.png" alt="round 4"></p><h4 id="Round-5"><a href="#Round-5" class="headerlink" title="Round 5"></a>Round 5</h4><p><img src="/images/blog/sync-round5.png" alt="round 5"></p><hr><h2 id="synchronized-迭代改进"><a href="#synchronized-迭代改进" class="headerlink" title="synchronized 迭代改进"></a>synchronized 迭代改进</h2><p>我们首先需要了解 synchronized 的两个特性，::可重入::和::非公平性::。</p><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>还是从实际的代码入手，看看可重入是怎么回事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// do fetching job...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value != get()) &#123;</span><br><span class="line"><span class="comment">// do updating job...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码有两个对外提供的同步方法，其中 update 会在内部调用 get 方法。可重入是指，一个线程在已经持有锁的情况下，再次获取锁时能够自动获得，不会因为没有锁没有释放掉进入等待状态。在每次获得锁的时候，标记数+1，每次释放锁的时候，标记数-1，当标记数为0的时候，锁才会被完全释放掉。</p><p>可重入锁的好处显而易见，对开发友好，避免死锁。</p><h3 id="非公平性"><a href="#非公平性" class="headerlink" title="非公平性"></a>非公平性</h3><p>公平性是指锁严格遵循 ::FIFO::，这样可以避免线程饿死的情况，但现在大部分锁都是非公平性的，这是为什么？</p><p>这需要结合后面的知识来说明，但大家知道非公平性锁，会减少线程切换次数，且不需要维护线程顺序，小不少开销。</p><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>从前面的章节里面，能够了解锁的实现，需要调用操作系统的互斥量，那这就必须涉及到系统调用，内核切换，开销很大。这种方式也被称之为重量级锁。</p><p>那有没有可能，减少这种开销了？Java 进行了一系列优化，咱们一步一步地看看。</p><p>先放出一张图，大家感受一下（<del>坏笑</del>）<br><img src="/images/blog/sync-optimize.png" alt="sync optimize"></p><p>我们首先来想这样一个问题，线程的竞争是否真的激烈？在绝大多数时间内，是否只有一个线程在实际运行？就算是两个线程，它们是不是交替进行的了？如果真的是同时运行，有竞争关系，那才有必要使用重量级锁🔒。</p><p>于是乎，我们就有了一下几种锁<br>偏向锁：只有一个线程进入临界区；<br>轻量级锁：多个线程交替进入临界区；<br>重量级锁：多个线程同时进入临界区。</p><p>前面提及到锁，都是基于对象的，那么我将对应的状态记录到对象里面去，后续根据对象的状态，使用不同的锁，那就能达到优化的目的了。</p><p>事实上，java 就是这么优化锁的，object 里面的线程状态字段叫做::Mark Word::。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述同步代码块中存在一个临界区，假设当前存在 Thread1 和 Thread2 这两个用户线程，分三种情况来讨论。</p><p>Case 1：只有 Thread1 会进入临界区；<br>Case 2： Thread1 和 Thread2 交替进入临界区；<br>Case 3： Thread1 和 Thread2 同时进入临界区。</p><p>上述的情况一是偏向锁的适用场景，此时当 Thread1 进入临界区时，JVM会将lockObject的对象头Mark Word的锁标志位设为“01”，同时会用CAS操作把 Thread1 的线程ID记录到 MarkWord 中，此时进入偏向模式。所谓“偏向”，指的是这个锁会偏向于 Thread1 ，若接下来没有其他线程进入临界区，则 Thread1 再出入临界区无需再执行任何同步操作。也就是说，若只有 Thread1 会进入临界区，实际上只有 Thread1 初次进入临界区时需要执行CAS操作，以后再出入临界区都不会有同步操作带来的开销。</p><p>然而情况一是一个比较理想的情况，更多时候 Thread2 也会尝试进入临界区。若 Thread2 尝试进入时 Thread1 已退出临界区，即此时lockObject处于未锁定状态，这时说明偏向锁上发生了竞争（对应情况二），此时会撤销偏向，Mark Word中不再存放偏向线程ID，而是存放hashCode和GC分代年龄，同时锁标识位变为“01”（表示未锁定），这时 Thread2 会获取lockObject的轻量级锁。因为此时 Thread1 和 Thread2 交替进入临界区，所以偏向锁无法满足需求，需要膨胀到轻量级锁。</p><p>轻量级锁在实际执行过程中，是针对两个线程交替进行的，实则没有竞争。再说轻量级锁什么时候会膨胀到重量级锁。若一直是 Thread1 和 Thread2 交替进入临界区，那么没有问题，轻量锁hold住。一旦在轻量级锁上发生竞争，即出现“ Thread1 和 Thread2 同时进入临界区”的情况，轻量级锁就hold不住了。 </p><p>就算轻量级锁失败，也不一定会真正在操作系统层面上进行挂起，还会有一项叫做自旋锁的优化方案。</p><p>自旋锁基于这样一种假设，需要持有锁的时间可能非常的短，那为这点时间，进行系统调用，状态切换很不知道。那么可以让线程进入轮询状态，等待锁的释放，不让出 CPU 资源。如果得到锁，就顺利进入竞争区，否则在一定次数过后，还是不能获得锁，就在操作系统上进行操作。后续，Java 继续优化，自旋的策略，自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p><p>除了前面的锁优化策略，Java 还做了::锁消除::和::锁粗化::来优化。</p><p>锁消除是指，<code>万恶的JIT</code>会在运行时，扫描上下文，去消除一些不可能存在竞争的锁。例如以下的代码，在实际运行时，并不存在 object 的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">justDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">        <span class="comment">// just a block</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁粗化是指扩大锁的范围，避免反复加锁和释放锁，例如下面的代码，在循环中进行加锁和释放锁，代价有点大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thinLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际运行时，JIT 会对次进行优化，等价于下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roughLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://docs.oracle.com/javase/specs/jls/se12/html/index.html" target="_blank" rel="noopener">The Java® Language Specification</a></li><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf" target="_blank" rel="noopener">JavaTM Memory Model and Thread Specification</a></li><li><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">GitHub - CL0610/Java-concurrency: Java并发知识点总结</a></li><li><a href="https://mp.weixin.qq.com/s/3HCWuE4EQNOKbX6G6oOYpQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/3HCWuE4EQNOKbX6G6oOYpQ</a></li><li><a href="http://www.hollischuang.com/archives/2550" target="_blank" rel="noopener">再有人问你Java内存模型是什么，就把这篇文章发给他。-HollisChuang’s Blog</a></li><li><a href="https://zhuanlan.zhihu.com/p/56191979" target="_blank" rel="noopener">漫画：什么是volatile关键字？ - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/43526907" target="_blank" rel="noopener">volatile与内存屏障总结 - 知乎</a></li><li><a href="https://www.jianshu.com/p/2ab5e3d7e510" target="_blank" rel="noopener">内存屏障 - 简书</a></li><li><a href="https://zhuanlan.zhihu.com/p/75880892" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/75880892</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年08月09日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/atom.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      这篇文章将重点介绍了
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="concurrency" scheme="http://www.woaitqs.cc/tags/concurrency/"/>
    
      <category term="volatile" scheme="http://www.woaitqs.cc/tags/volatile/"/>
    
      <category term="synchronized" scheme="http://www.woaitqs.cc/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>关于泛型你应该知道的</title>
    <link href="http://www.woaitqs.cc/2019/08/01/2019-08-01-about-generic/"/>
    <id>http://www.woaitqs.cc/2019/08/01/2019-08-01-about-generic/</id>
    <published>2019-08-01T02:19:47.000Z</published>
    <updated>2019-08-26T12:49:27.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为什么会存在泛型？我们先从一个简要的例子出发。</p><p>List Queue Stack等 M 种数据类型，Sort、Search、Find等 N 种操作，那我们需要实现 List X Sort、Stack X Find 等 M X N 种方法。类型与算法紧密地耦合在一起，这样显然不太合理，于是乎为了解决这种问题，在 1989 年的时候，Musser &amp; Stepanov 第一次提出了 Generic Programming(泛型编程) 的概念。</p><blockquote><p>Generic programming centers aroudn the idea of abstracting from concrete, efficient algorthms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.</p></blockquote><p>个人认为泛型有两个最重要的特点:</p><ol><li>参数类型化。</li><li>屏蔽掉数据细节，让算法更通用。Programmer 能够更关注算法本身，而不是在算法中处理各种数据细节。</li></ol><p>开发语言发展至今，泛型在几乎所有主流语言中都得到了不同程度的支持，无论是 C++、Kotlin、Java、C# 等等语言。但泛型的实现方式与语言的关系非常大，有相当多的细节不同。对于同样的内存区域，很难玩出花样，泛型是架构在语言之上的高级特性。</p><p>下面咱们看看 Java/Kotlin 中，泛型有哪些需要实现的地方。</p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>首先我们看看这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = gson.fromJson(json, Person.class)</span><br></pre></td></tr></table></figure><p>这里的问题在于，为什么还需要手动传入 <code>Person.class</code> 了？不是已经有前面 Person 的类型了吗？这里衍生出一个名词<code>类型擦除</code>。</p><blockquote><p>Java 实现的其实是伪泛型，即在编译的时候将类型类型移除掉，这就是类型擦除。</p></blockquote><p>我们来做这样一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.data = data;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> data;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="keyword">new</span> Box&lt;String&gt;().getClass());</span><br><span class="line">System.out.println(<span class="keyword">new</span> Box&lt;Long&gt;().getClass());</span><br></pre></td></tr></table></figure><p>输出的都是 <code>Box</code>，并没有泛型的信息，因为这些类型信息都在编译后被抹除掉了，实际编译生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">uc</span>.<span class="title">vmate</span>.<span class="title">demo</span>.<span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.uc.vmate.demo.Box(T);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0</span><br><span class="line">       <span class="number">5</span>: aload_1</span><br><span class="line">       6: putfield      #2 // Field data:Ljava/lang/Object;</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: getfield      #2 // Field data:Ljava/lang/Object;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中我们可以看到，并没有什么 T 类型，全部都变成了 Object。那么为什么 Java 要这么做呢？为什么要把已经带上的信息抹除掉？原因就是为了向后兼容，兼容以前的 JVM 版本，为了诸如 ArrayList 能够和 ArrayList<t> 共存这样的 Case。但这也导致了 Java 的泛型算半个畸形产物，是个<code>伪泛型</code>，或者你可以这么想想，泛型类内部不知道自己是什么类型。</t></p><blockquote><p>Java 泛型 ~= 编译器魔法</p></blockquote><p>简单的步骤如下:</p><ol><li><strong>检查</strong>  并获得泛型的<strong>实际类型</strong>, 然后存到class文件中</li><li><strong>擦除</strong>原有类型 , 替换为<strong>限定</strong>类型（<code>T/E</code>等无限定类型, 用Object替换）</li><li>最后, 调用相关函数将结果<strong>强制转换</strong>为目标类型</li></ol><p>而 C# 没有类型擦除，是真正的泛型。C# 的泛型，将泛型编译成元数据，通过 CLR 运行时，JIT 即时编译，将 IL 代码即时编译成相应类型的特化代码。</p><p><img src="/images/blog/csharp-generic.png" alt="C# Template"></p><hr><h2 id="泛型通配"><a href="#泛型通配" class="headerlink" title="泛型通配"></a>泛型通配</h2><p>我们再看看泛型通配的问题，首先我们设想这样一种场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Fruit&gt; fruitList = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// check this case.</span></span><br><span class="line">fruitList = appleList;</span><br><span class="line">appleList = fruitList;</span><br></pre></td></tr></table></figure><p>上面最后两句会编译通过吗？当然不能编译通过。我们简单设想一下，如果 <code>appleList = fruitList</code> 如果这句话编译没有问题，那么 appleList 里面就能放入 pear，这显然不合理。同样 <code>fruitList = appleList</code> 如果成立的话，也能导致 appleList 里面放入 pear。由此我们可以看到，fruitList 与 appleList 是两个完全没有关系的类。</p><p>但有另一个问题就冒出来了，看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">static</span> <span class="title">dumpList</span><span class="params">(List&lt;Fruit&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Fruit fruit: list) &#123;</span><br><span class="line">System.out.println(fruit)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们在实际使用的时候，并不能传入 List&lt; Apple &gt;，List&lt; Banner &gt;，因为两种不是同一个东西。</p><p>这里我们先引入协变和逆变的概念。</p><blockquote><ul><li>当A ≦ B时,如果有f(A) ≦ f(B),那么f叫做<strong>协变</strong>；</li><li>当A ≦ B时,如果有f(B) ≦ f(A),那么f叫做<strong>逆变</strong>；</li><li>如果上面两种关系都不成立则叫做<strong>不可变</strong>。</li></ul></blockquote><p>如果把<strong>协变</strong>的概念，代入到上面的例子中来看看，如果是协变的，那么我们就能将 List&lt; Apple &gt; 传入进去。反过来如果是<strong>逆变</strong>的，那么我们就能将 List&lt; Food &gt; 传入其中。</p><p>那么 Java 是用什么样的语法糖来表达 协变 和 逆变的了？</p><p>? 是 java 中的通配符，用来表征任何类型，List&lt;?&gt; 就可以传入任何类型的 List了。如果是 <code>? extends</code> ，这就是协变，可以把子类类型的 List 传入。如果是 <code>? super</code>，这是逆变，可以传入父类类型的 List。</p><p>在 Kotlin 中简化了协变和逆变的表达，分别用 out 和 in 来表达。</p><p>p.s. java 的数组是天生协变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可变</span></span><br><span class="line">List&lt;Fruit&gt; fruits = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();<span class="comment">// 编译不通过</span></span><br><span class="line"><span class="comment">// 协变</span></span><br><span class="line">List&lt;? extends Fruit&gt; wildcardFruits = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line"><span class="comment">// 协变-&gt;方法的返回值，对返回类型是协变的:Fruit-&gt;Apple</span></span><br><span class="line">Fruit fruit = wildcardFruits.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 不可变</span></span><br><span class="line">List&lt;Apple&gt; apples = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();<span class="comment">// 编译不通过</span></span><br><span class="line"><span class="comment">// 逆变</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Apple&gt; wildcardApples = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line"><span class="comment">// 逆变-&gt;方法的参数，对输入类型是逆变的:Apple-&gt;Fruit</span></span><br><span class="line">wildcardApples.add(<span class="keyword">new</span> Apple());</span><br></pre></td></tr></table></figure><p>咱们还需要考虑<code>返回值</code>和<code>参数</code>哦！这里直接抛出结论，Java 对返回值是支持<code>协变</code>的，否则你想想，在一个申明返回 Fruit 的函数里面，返回一个 Apple 是错误的话，那是多么可怕的事情。另一方面，对于参数的类型，Java 是通过方法重载来实现的。直接看看下面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;? extends Fruit&gt; get() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">desc</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">desc</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.imbajin.com/2018-09-28-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E6%B3%9B%E5%9E%8B/" target="_blank" rel="noopener">https://www.imbajin.com/2018-09-28-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E6%B3%9B%E5%9E%8B/</a></li><li><a href="http://blog.zhaojie.me/2010/05/why-java-sucks-and-csharp-rocks-4-generics.html" target="_blank" rel="noopener">http://blog.zhaojie.me/2010/05/why-java-sucks-and-csharp-rocks-4-generics.html</a></li><li><a href="https://yq.aliyun.com/articles/640124" target="_blank" rel="noopener">https://yq.aliyun.com/articles/640124</a></li><li><a href="https://zhanjindong.com/2014/09/21/understand-covariance-and-contravariance-again" target="_blank" rel="noopener">https://zhanjindong.com/2014/09/21/understand-covariance-and-contravariance-again</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2019年08月01日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      这篇文章将重点介绍了泛型相关的知识，泛型统配，协变和逆变等等
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="generic" scheme="http://www.woaitqs.cc/tags/generic/"/>
    
  </entry>
  
  <entry>
    <title>Android MediaCodec 退坑指南</title>
    <link href="http://www.woaitqs.cc/2018/11/26/2018-11-26-how-to-use-mediacodec-correctly/"/>
    <id>http://www.woaitqs.cc/2018/11/26/2018-11-26-how-to-use-mediacodec-correctly/</id>
    <published>2018-11-26T12:48:09.000Z</published>
    <updated>2019-07-26T14:16:40.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MediaCodec-Introduction"><a href="#MediaCodec-Introduction" class="headerlink" title="MediaCodec Introduction"></a>MediaCodec Introduction</h2><p>MediaCodec 是 Android 音视频开发中不可能绕过的环节，但它真的不太好用，小水坑太多。今天我们就趟趟小水坑，走进科学，oh，不，走进 MediaCodec。</p><p>MediaCodec 是 Android 多媒体支持框架中的一员，其他还包括 MediaExtractor、MediaSync、MediaMuxer、MediaDrm 等等，负责编解码相关的工作。接下来我们简单地介绍下 MediaCodec 是如何工作的。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>In broad terms，编解码器处理输入数据并产生输出数据，MediaCodec 使用输入输出缓存，异步处理数据。简要地说，一般的处理步骤如下</p><ol><li>请求一个空的输入 input buffer</li><li>填入数据、并将其交给 MediaCodec</li><li>MediaCodec 处理数据后，将处理后的数据放在一个空的 output buffer</li><li>获取填充数据了的 output buffer，得到其中的数据，然后将其返还给 MediaCodec。</li></ol><p>下图是对步骤的阐释</p><p><img src="https://i.loli.net/2018/11/26/5bfbe93ff158d.png" alt="工作流程"></p><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>我们的大脑不是万能的，MediaCodec 也不是什么数据都能支持的。一般在有限的范围内运转的系统，稳定且可靠，嘿嘿嘿。MediaCodec 支持三种数据格式，下面分别介绍：</p><ol><li><p>Compressed Data<br>既然是编解码器，那么势必会处理对应视频、音频格式的压缩数据，也就是 Encode 的输出数据、Decoder的输入数据。我们将这一类数据，统称为压缩数据。压缩数据格式，取决于 <a href="https://developer.android.com/reference/android/media/MediaFormat#KEY_MIME" target="_blank" rel="noopener">MediaFormat  |  Android Developers</a>。对于视频数据而言，通常是一帧数据；音频数据，一般是单个处理单元(包括多少微秒的数据)。一般情况下，除非指定为 <code>BUFFER_FLAG_PARTIAL_FRAME</code>，否则不会出现半个帧的情况。</p></li><li><p>Raw Audio Buffers<br>编解码器，需要编码对应的音频数据，那么就肯定会处理音频格式数据，也就是 PCM 数据。对于音频编码格式，只有 ENCODING_PCM_16BIT  确认被各 System \ Rom 支持哦。</p></li></ol><p>这里简要滴摘录下 Wiki 上关于 PCM 数据的定义。</p><p><img src="https://i.loli.net/2018/11/26/5bfbe99fd9ed8.png" alt="How PCM Work?"></p><blockquote><p>PCM就是把一个时间连续，取值连续的模拟信号变换成时间离散，取值离散的数字信号后在信道中传输。简而言之PCM就是对模拟信号先抽样，再对样值幅度量化，编码的过程。例如听到的声音就是模拟信号，然后对声音采样，量化，编码产生数字信号。相对自然界声音信号，任何音频编码都是有损的，在计算机应用中，能达到高保真的就是PCM编码，因此PCM约定成俗成了无损编码，对于声音而言，我们通常采用PCM编码。</p></blockquote><ol start="3"><li>Raw Video Buffers<br> a.  Native raw video format. 也就是MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface，注意这种格式，并不是所有 Android 手机都支持的哦。<br> b. YUV buffers.  可以用在 Surface 格式，或者 ByteBuffer 格式中。Google 表示在 API 22 以后，所有机型都保证支持 YUV 4:2:0 格式。<br> c. Other formats. 这就看厂商心情了，可以通过 MediaCodecInfo.CodecCapabilities 来进行查询。</li></ol><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p><img src="https://i.loli.net/2018/11/26/5bfbe9ec9ca38.png" alt="MediaCodec 状态机"></p><p>MediaCodec 大体上分为三种状态、Stopped、Executing和 Released。状态机工作图如上，其后就是很具体的调用细节了。</p><p>具体的状态切换就不翻译了，大家可以通过上面的图，结合英文看一看。</p><p>When you create a codec using one of the factory methods, the codec is in the Uninitialized state. First, you need to configure it via configure(…), which brings it to the Configured state, then call start() to move it to the Executing state. In this state you can process data through the buffer queue manipulation described above.</p><p>The Executing state has three sub-states: Flushed, Running and End-of-Stream. Immediately after start() the codec is in the Flushed sub-state, where it holds all the buffers. As soon as the first input buffer is dequeued, the codec moves to the Running sub-state, where it spends most of its life. When you queue an input buffer with the end-of-stream marker, the codec transitions to the End-of-Stream sub-state. In this state the codec no longer accepts further input buffers, but still generates output buffers until the end-of-stream is reached on the output. You can move back to the Flushed sub-state at any time while in the Executing state using flush().</p><p>Call stop() to return the codec to the Uninitialized state, whereupon it may be configured again. When you are done using a codec, you must release it by calling release().</p><p>On rare occasions the codec may encounter an error and move to the Error state. This is communicated using an invalid return value from a queuing operation, or sometimes via an exception. Call reset() to make the codec usable again. You can call it from any state to move the codec back to the Uninitialized state. Otherwise, call release() to move to the terminal Released state.</p><hr><h2 id="MediaCodec-Usage-Tips"><a href="#MediaCodec-Usage-Tips" class="headerlink" title="MediaCodec Usage Tips"></a>MediaCodec Usage Tips</h2><p>接下来讲讲，如何用正确的姿势 <del>（知识）</del>来使用 MediaCodec，毕竟这家伙在不同手机、不同系统上面都表现不同。对它的正确使用，不太考验技术，更考验经验和细心。</p><h3 id="Create-Instance"><a href="#Create-Instance" class="headerlink" title="Create Instance"></a>Create Instance</h3><p>首先是如何创建 MediaCodec，在创建 MediaCodec 时，需要弄清楚自己是想创建 Encoder 还是 Decoder。</p><p>在知晓 <a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">Media Types</a> 的情况下，可通过 createDecoderByType, createEncoderByType, createByCodecName 方法来获取实例。</p><p>问题在于如何确定手机是否支持该 MimeType 呢？在 API 21 上，可以使用 MediaCodecList.findDecoderForFormat、MediaCodecList.findEncoderForFormat 这两个方法来进行获取，如果有满足需求的Codec，会返回对应 MimeType。这里需要说明的是，需要在 LOLLIPOP 版本上，::<strong>清除掉 Format 中关于 KEY_FRAME_RATE 的设置</strong>::，无疑这是一个小坑。</p><p>Android 底层的多媒体框架采用了 OpenMax 标准，但具体的硬件编解码功能，则是有各个产商负责的，这就导致不同手机可能差异很多，也是 Android 多媒体框架兼容性问题大的根源。那么我们如何来处理哪怕仅仅是创建就会碰到的兼容性问题呢？</p><blockquote><p>以下，包括接下来章节的内容，大部分都是通过官方的 <a href="https://source.android.com/compatibility/android-cdd.pdf" target="_blank" rel="noopener">Compatibility Definition Document</a> 和 <a href="https://developer.android.com/guide/topics/media/media-formats" target="_blank" rel="noopener">Supported media formats  |  Android Developers</a> 来作为参考的，后面就不重复解释了。</p></blockquote><h4 id="Audio-Codec"><a href="#Audio-Codec" class="headerlink" title="Audio Codec"></a>Audio Codec</h4><p><del>遇事不决，看下面的图</del><br><img src="https://i.loli.net/2018/11/26/5bfbea1912ab7.png" alt="MediaCodec Support Details"></p><p>从上图可以看到，对于大部分音频解码而言，都是支持的。在实际开发中，当解码一个音频的时候，不用做什么特殊处理，处理好可能的 Crash，正常解码就行。反倒是，在音频编码的时候需要注意。对于有录音Mic权限的手机而言，官方保证支持 PCM/WAVE 可以用于编码，但我们对这个的使用较少。另外可以看到我们熟悉的 MP3 格式，并不在支持之列哟。我们使用的是另一种几乎所有设备都支持的编码格式，m4a，其 MimeType 就是 “::audio/mp4a-latm::”。</p><blockquote><p>m4a 听上去很奇怪，其实就是 MPEG-4 Audio 的简写。苹果公司为了区分包含视频、音频的MP4文件与只有音频的MP4文件，对后者进行了单独命名::.m4a::，这种格式对现今绝大部分移动设备都支持。<br>M4A is a file extension for an audio file encoded with advanced audio coding (AAC) which is a lossy compression. M4A was generally intended as the successor to MP3, which had not been originally designed for audio only but was layer III in an MPEG 1 or 2 video files. M4A stands for MPEG 4 Audio.</p></blockquote><h4 id="Video-Codec"><a href="#Video-Codec" class="headerlink" title="Video Codec"></a>Video Codec</h4><p><del>同样遇事不决，看下面的图</del><br><img src="https://i.loli.net/2018/11/26/5bfbea4d48356.png" alt="Video Support Details"></p><p>VP8/9 适用性没有 H.264 来的广，就略过不谈了；263 在 7.0 以上才可以用而且没有H.264来的广；265相关的，Android 不太支持。最后也就剩下 H.264 AVC 啦。关于 H.264 AVC Main Profile (MP) 与 H.264 AVC Main Profile (HP) 了，得在更高阶的 Android 系统(7.0 +) 才开始支持，而且会有一定的兼容性问题，这个在后面会专门提及。综合起来呢，要先做到最全的兼容性，让几乎在所有机型上都能运作，选用 H.264 BaseLine 作为编码器，是一个不错的选择。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>在创建好 MediaCodec 过后，需要对其进行配置，这样 MediaCodec 的状态就可以由 uninitiated 变成 configured。</p><p><img src="https://i.loli.net/2018/11/26/5bfbea729c0c3.png" alt="configure"></p><p>这里最重要的参数是 MediaFormat，要敲黑板啦！</p><ol><li>某些 MediaFormat 没有设置的话，会导致 MediaCodec 抛出 IllegalStateException 哦！<strong>all keys not marked optional are mandatory !!</strong></li><li>参数设置不对，也可能会抛出异常哦。比如设置一个超出手机能力范围外的分辨率。</li></ol><p>Video 所必须的 Format Setting。<br><img src="https://i.loli.net/2018/11/26/5bfbeaab2d234.png" alt="Video Format Setting"></p><p>Audio 所必须的 Format Setting。<br><img src="https://i.loli.net/2018/11/26/5bfbeaab37eb9.png" alt="Audio Format Setting"></p><p>下面说几个需要特别注意的几个设置项。</p><p><code>KEY_WIDTH 与 KEY_HEIGHT</code></p><p>在编码的时候，请务必保证两者是16的整数倍。</p><p><code>KEY_BIT_RATE &amp; KEY_FRAME_RATE</code></p><p>BIT_RATE 没有什么太大的坑，注意下单位就好 bits/seconds. 下面的图展示了，官方要求设备对于不同分辨率下需要支持的最低分辨率。</p><p>FRAME_RATE 也同样，几乎都被要求支持至少 30 FPS。(<del>但实际能否达到 30 FPS 的效果，就很难说了，此外 FPS 的设置还会和 Camera 预览的亮度有一定关系哦</del>，结合<a href="http://www.woaitqs.cc/2018/09/01/how-to-take-a-beautiful-and-right-picture/">光影的秘密 | Coding And Living | Qisen Tang - Android Developer</a> 体会一下)</p><p><img src="https://i.loli.net/2018/11/26/5bfbeae8d9794.png" alt="编码的最小支持"></p><p><img src="https://i.loli.net/2018/11/26/5bfbeae7b3af7.png" alt="解码的最小支持"></p><p><code>KEY_COLOR_FORMAT</code></p><p>CDD 文档中要求，::If device implementations include a video decoder or encoder，Video encoders and decoders MUST support YUV420 flexible color format(COLOR_FormatYUV420Flexible)::。COLOR_FormatYUV420Flexible 是在 API 21 才开始引入的，而且是一种<code>魔法</code>格式，可以代表很多格式。</p><blockquote><p>Chroma planes are subsampled by 2 both horizontally and vertically. Use this format with Image. This format corresponds to ImageFormat.YUV_420_888, and can represent the COLOR_FormatYUV411Planar, COLOR_FormatYUV411PackedPlanar, COLOR_FormatYUV420Planar, COLOR_FormatYUV420PackedPlanar, COLOR_FormatYUV420SemiPlanar and COLOR_FormatYUV420PackedSemiPlanar formats.<br>虽然这种格式被21版本后所有手机都支持，但使用的时候需要结合 <a href="https://developer.android.com/reference/android/media/Image" target="_blank" rel="noopener">Image  |  Android Developers</a> 来使用，getOutputImage / getInputImage。</p></blockquote><p>在更低的版本时，需要设置具体的 Color_Format，基本上大部分设备都支持 COLOR_FormatYUV420SemiPlanar 或者 COLOR_FormatYUV420Planar。我们只需要处理这两种 Color_Format 就可以了。</p><p>这里还有一个坑，是在某些设备上 ColorFormat 所表示的格式可能是反的，比如NV12 与 NV21。建议尽可能地使用前面章节提到的Surface input API 来规避这些问题。</p><p><code>KEY_I_FRAME_INTERVAL</code></p><p>通常的方案是设置为 1s，对于图片电影等等特殊情况，这里可以设置为 0，表示希望每一帧都是 KeyFrame。</p><p>但要想达到精确的帧率控制不太现实，尽量使用 Surface，尽量在流程中不占用过多资源，没有明显卡顿耗时，这样得出的帧率相对更好一些。</p><p><code>KEY_PROFILE &amp; KEY_LEVEL</code></p><p>这里设置编码级别，注意这里 Profile 必须和 level 配对，下面的代码是一个简单的示例。</p><p><img src="https://i.loli.net/2018/11/26/5bfbeb2176c86.png" alt="profile"></p><p>这里 Profile 级别的设置是一个深坑。</p><ol><li>深坑 NO.1 -&gt; 在 Android 7.0 以前，不管你怎么设置 Profile 级别，最后都会使用 BaseLine，因为这在源码里面写死了。。。</li><li>深坑 NO.2 -&gt; Main 或者 High Profile 能够带来更高的压缩比和其他好处，但并不意味着它的兼容性就很好。在某杂粮手机，Oppo手机的部分机型中，使用 High Profile 会导致 pts 和 dts 时间不一致，从而在播放的时候会画面来回跳动。（<del>至今不知道怎么爬出这个坑，还是老实用回 BaseLine 了</del>）</li></ol><p>尽管如此，还是建议大家尽量使用 High/Main 这样的 Profile，新方案新技术，只有使用才能发挥价值。</p><p>额外地说一下，我们开发录音功能时，使用 AudioRecorder，并将相应的数据送给编码器。这里在配置 AudioRecorder 时，最好将 PCM 的格式设置为 ::ENCODING_PCM_16BIT::，采样率设置为 ::44100Hz:: (44100 is currently the only rate that is guaranteed to work on all devices)，声道设置为::单声道:: ({@link AudioFormat#CHANNEL_IN_MONO} is guaranteed to work on all devices)。<del>用 Android 多媒体框架就应该求生欲极强</del>。</p><p><code>KEY_IS_ADTS</code></p><blockquote><p>A key mapping to a value of 1 if the content is AAC audio and audio frames are prefixed with an ADTS header. The associated value is an integer (0 or 1). This key is only supported when <em>decoding</em> content, it cannot be used to configure an encoder to emit ADTS output.</p></blockquote><p>这个设置项只在解码音频的时候才有用，单独拎出来还是因为其有坑。通常情况下，我们不需要去理会 ADTS，直接使用回调中的 Format 就可以了。但在魅族某些机型上，Format 可能会有错误，对于这种情况时，还是手动设置 KEY_IS_ADTS 为 1 比较好。</p><h2 id="Other-Tips"><a href="#Other-Tips" class="headerlink" title="Other Tips"></a>Other Tips</h2><p>真正在使用 MediaCodec 的时候，还会遇到一些小坑，接下来简单地介绍下。（<del>具体怎么用 MediaCodec ，网上很多资料就不讲啦</del>）</p><ol><li>保证 output 数据与 muxer 数据，在同一个线程上，否则可能出现花屏等现象。</li><li>createInputSurface() 需要在 configure 之后，与 start 之前，否贼可能创建失败。</li><li>处理数据时，需要处理 position 与 offset。</li></ol><p>还有一些其他 Tips，诸君一起来更新呀~</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.bigflake.com/mediacodec/" target="_blank" rel="noopener">Android MediaCodec stuff</a></li><li><a href="https://source.android.com/compatibility/android-cdd.pdf" target="_blank" rel="noopener">Android Compatibility Definition Document</a> </li><li><a href="https://developer.android.com/reference/android/media/MediaCodec" target="_blank" rel="noopener">MediaCodec  |  Android Developers</a></li><li><a href="https://android.googlesource.com/platform/cts/+/jb-mr2-release/tests/tests/media/src/android/media/cts" target="_blank" rel="noopener">tests/tests/media/src/android/media/cts - platform/cts - Git at Google</a></li><li><a href="https://github.com/OnlyInAmerica/HWEncoderExperiments" target="_blank" rel="noopener">GitHub - OnlyInAmerica/HWEncoderExperiments: Deprecated ( See https://github.com/Kickflip/kickflip-android-sdk for my current work). Experiments with Android 4.3’s MediaCodec and MediaMuxer</a></li><li><a href="https://github.com/videolan/vlc" target="_blank" rel="noopener">GitHub - videolan/vlc: VLC media player - All pull requests are ignored, please follow https://wiki.videolan.org/Sending_Patches_VLC/</a></li><li><a href="https://android.googlesource.com/platform/cts/+/jb-mr2-release/tests/tests/media/src/android/media/cts/" target="_blank" rel="noopener">tests/tests/media/src/android/media/cts - platform/cts - Git at Google</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2018年11月26日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      这篇文章将重点介绍了，硬编硬解过程中遇到的坑，也给读者朋友架构方案时提供一点参考
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/tags/android/"/>
    
      <category term="camera" scheme="http://www.woaitqs.cc/tags/camera/"/>
    
      <category term="ugc" scheme="http://www.woaitqs.cc/tags/ugc/"/>
    
      <category term="Tutorial" scheme="http://www.woaitqs.cc/tags/Tutorial/"/>
    
      <category term="mediacodec" scheme="http://www.woaitqs.cc/tags/mediacodec/"/>
    
  </entry>
  
  <entry>
    <title>光影的秘密</title>
    <link href="http://www.woaitqs.cc/2018/09/01/2018-11-10-how-to-take-a-beautiful-and-right-picture/"/>
    <id>http://www.woaitqs.cc/2018/09/01/2018-11-10-how-to-take-a-beautiful-and-right-picture/</id>
    <published>2018-09-01T08:52:50.000Z</published>
    <updated>2019-07-26T14:35:58.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相机的基本原理"><a href="#相机的基本原理" class="headerlink" title="相机的基本原理"></a>相机的基本原理</h2><p>手机拍摄的原理，解释起来并不复杂，大体上就是小孔成像的升级版。光源通过光圈在设定时间内，让光进入传感器，并停留指定时间，经过数字化处理，最后呈现出图像。听上去很乏味，对吧，但给自己一点点耐心，要看我哦。( <del>并不是为了给我面子</del> )</p><p>人眼能直接看到的，是直射或者反射的光线。当光线打在一个物体上时，会进行反射，从而我们能够看到物体。通常情况下，物体表面不是光滑的，光射到粗糙物体表面时，会无序地向各个方向反射，这种现象又称为漫反射。设想我们在墙壁上凿一个小孔，漫反射的光会进入小孔，从而在另一端的墙壁上显出一个倒立的影子。这就是小孔成像啦，相机基于的原理也就是这个。</p><p><img src="https://i.loli.net/2018/11/09/5be5827a3c95a.png" alt="小孔成像"></p><hr><h2 id="相机的三要素"><a href="#相机的三要素" class="headerlink" title="相机的三要素"></a>相机的三要素</h2><p>有很多方面可以决定一张照片的质量，有多少光线进入镜头，多长时间段的光线进入，队这些光线的敏感度如何，这分别就是相机的三要素。</p><h3 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h3><p>光圈的大小直接影响进入传感器的光的大小。</p><blockquote><p>光圈是一个用来控制光线透过镜头，进入机身内感光面的光量的装置，它通常是在镜头内。表达光圈大小我们是用f值。对于已经制造好的镜头，我们不可能随意改变镜头的直径，但是我们可以通过在镜头内部加入多边形或者圆型，并且面积可变的孔状光栅来达到控制镜头通光量，这个装置就叫做光圈。</p></blockquote><p><img src="https://i.loli.net/2018/11/09/5be582aa2c3b6.png" alt="光圈示例"></p><p>下面分别展示大光圈和小光圈下的两张图片，区别一目了然。</p><p><img src="https://i.loli.net/2018/11/09/5be582f532f8e.png" alt="大光圈"><br><img src="https://i.loli.net/2018/11/09/5be582ff681fc.png" alt="小光圈"></p><p>P.S. 大部分手机设备，都没有做多级光圈的支持，也就是说大部分设备都是一种光圈。所以除非自身的手机支持，这一条可以忽略啦，来打我呀。写在这里，是作为科普知识哒~</p><h3 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h3><p>决定的是，允许多长时间的光进入传感器。快门时间越长，进入的光线也就越多，从而照片会偏亮。拍摄较暗环境时，需要较长的快门，否则容易显示不清晰；反过来对于光亮充足的环境下，需要较短的快门，否则容易过度曝光。</p><p>下图分别是 0.6S 和 15S 快门下的两组照片，足够长的快门下，就有足量的光进入传感器，从而有车流的感受。</p><p><img src="https://i.loli.net/2018/11/09/5be58350c2ff2.png" alt="短快门"><br><img src="https://i.loli.net/2018/11/09/5be58351d22a8.png" alt="长快门"></p><h3 id="感光度"><a href="#感光度" class="headerlink" title="感光度"></a>感光度</h3><blockquote><p>感光度，又称为ISO值，是衡量底片对于光的灵敏程度，由敏感度测量学及测量数个数值来决定，最近已经被国际标准化组织标准化。</p></blockquote><p>感光度很好理解，感光度越高，对光的敏感程度也越好，越容易拍亮物体。但值得注意的是，感光度越高，噪点也会更明显，想要用得好，还得多实践。</p><p><del>此处有视频演示，微信公众号上传视频真麻烦，有兴趣的童鞋微信联系…</del></p><hr><h2 id="如何清晰成像"><a href="#如何清晰成像" class="headerlink" title="如何清晰成像"></a>如何清晰成像</h2><p>一束光经过透镜后，会在一个平面上清晰呈现，这个点叫做焦点，这个平面叫做焦平面，对于单一物体有且只有一个焦平面。实际上我们人眼在一定范围内都能认为是清晰成像的，无法做到那么严苛。</p><blockquote><p>对焦是指使用照相机时调整好焦点距离，使得画面能够在指定的部位呈现出想要的效果(大部分情况下都是希望清晰)。</p></blockquote><p>手机上的对焦与相机上的对焦有一定的差异，需要单独的说明下。一般而言，前置摄像都使用的是定焦镜头，且一般都是超焦距镜头。换而言之，只要用前置摄像头拍摄的照片，0.5m到无限远，都比较清晰。可能有人会问，我点击前置摄像头，画面变化很大的呀，那不是变焦，只是在测光，23333。</p><p>再来谈谈变焦效果，手机那么薄，配置一个需要前后伸缩的变焦镜头不太现实。那么手机的变焦效果是怎么实现的了？双摄！一般的摄像头，都会长焦和短焦搭配起来使用，我们看到的变焦效果，往往是两个摄像头配合起来工作，加上软件实现的算法才能工作。所以手机上的变焦速度，变焦效果，就能看出手机开发商的硬实力了。咳咳，我并没有批评某些手机哈~</p><p>现在手机为了大家更方便地进行拍摄，往往是测光加对焦，都可以轻触完成（哪里不清晰就点哪里）。此外，用户可以通过长按，来锁定焦距，这样就能完成不同的焦距效果。下面两张图片分别展示在不同焦距下的两张图片，照片清晰的部位不一样，意境也不相同。</p><p><img src="https://i.loli.net/2018/11/09/5be585adeb1ed.jpg" alt="对焦近处"></p><p><img src="https://i.loli.net/2018/11/09/5be585ae38c92.jpg" alt="对焦远处"></p><p>接下来谈谈弥散圆和景深效果。</p><p>在焦点前后，光线从聚集到扩散，点的影象从圆到点（焦点），继而有扩散到圆，这个焦点前面和后面的圆就叫做弥散圆，效果如下图。</p><p><img src="https://i.loli.net/2018/11/09/5be585ae48061.png" alt="弥散圆"></p><p>这里继续提及一下景深的概念，网上没有找到精确的定义，就我个人理解而言，景深是::能在相机中清晰成像的物体距离::。也就是说在其他条件固定不变的情况下，前后移动都能清晰成像的距离。</p><p><img src="https://i.loli.net/2018/11/09/5be585b14cac3.png" alt="图片来自于知乎(Marshal Lil)"></p><p>（1）光圈越大，景深越小；光圈越小，景深越大。<br>（2）镜头焦距越长，景深越小；焦距越短，景深越大。<br>（3）物距越长，景深越大；物距越短，景深越小。</p><hr><h2 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h2><p>前面提到了相机的三要素，那么通过这三个要素来达到什么样的目的呢？这里需要介绍下曝光的概念。一张照片如果太黑，那么用户看不清主体，反过来一张照片过白，用户也看不清主体。合适滴捕捉光影，是主体能够清晰地呈现，这就是曝光啦。理想上曝光是::18%灰::。</p><blockquote><p>18%的灰就是中性灰，指的是人眼看到的黑和白中间的那个亮度，相机上测光就是按照中性灰来测光的。</p></blockquote><p>18%灰不是指灰色这个色彩，而是指18度灰的反射率，在设计拍摄中，那物体靠近黑色的反射率就被判断为曝光不足，相机会给你增加曝光；而太靠近白色时的反射率就会被判断为曝光过度，相机会自动减少曝光。</p><p>拍雪景中的人，相机以为场景太白会给你减少曝光，人物就欠曝了。而你在黑色的煤场拍人，相机以为场景太黑会给你增加曝光，人物就会过曝。</p><p>相机本身是无法区分各种光线的，都是以 18% 作为曝光基准，如果画面达到这种程度，那么就会认为是曝光正确。所为测光，也就是使得测光的区域能达到这个标准。</p><p>单发相机相较于手机会多一些测光模式，这里都简要地说一下。</p><h3 id="平均测光"><a href="#平均测光" class="headerlink" title="平均测光"></a>平均测光</h3><p>平均测光的原理是将画面划分为多个区域，每个区域进行独立测光，然后依此计算出整个画面的测光平均值。</p><p>在拍摄光源较为充足的情况下，拍摄大气风景，人群团队的时候，很适用。</p><p><img src="https://i.loli.net/2018/11/10/5be63676daf54.png" alt="平均测光"></p><h3 id="中央重点测光"><a href="#中央重点测光" class="headerlink" title="中央重点测光"></a>中央重点测光</h3><blockquote><p>中央平均测光是采用最多的一种测光模式，几乎所有的相机生产厂商都将中央平均测光作为相机默认的测光方式。测光偏重于取景器中央，然后平均到整个场景。</p></blockquote><p>虽然是考虑整个画面，但会对中央区域进行加权，从而有所突出。这在拍摄人脸，中央突出等情况时，很好用。</p><p><img src="https://i.loli.net/2018/11/10/5be6366e870fd.png" alt="中央重点测光"></p><h3 id="点测光、局部测光"><a href="#点测光、局部测光" class="headerlink" title="点测光、局部测光"></a>点测光、局部测光</h3><blockquote><p>画面中很小的一个点状区域进行精确、独立的测光，而忽略画面其它部分。局部测光与点测光相似，选择画面的一部分进行测光，面积相对大一些，更适合拍摄体育题材、舞台剧题材等场景。</p></blockquote><p><img src="https://i.loli.net/2018/11/10/5be6366e7353b.png" alt="局部测光"></p><p>一下三组图片，分别展示了平均测光、中央重点测光、点测光下拍摄的照片。</p><p><img src="https://i.loli.net/2018/11/10/5be636c9bf628.png" alt="平均测光"><br><img src="https://i.loli.net/2018/11/10/5be636c947edd.png" alt="中央重点测光"><br><img src="https://i.loli.net/2018/11/10/5be636c9b2f30.png" alt="点测光"></p><p>下面这个视频，是华为 Honor 上进行的拍摄完成的。该手机上快门固定，光圈固定，随着测光区域的变化，相机只能调节 ISO 感光度来使得::测光区域达到 18% 灰的效果::。</p><p><del>此处有视频演示，微信公众号上传视频真麻烦，有兴趣的童鞋微信联系…</del></p><hr><h2 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h2><p>看上去很高级的东西，实际上就是一个::语法糖::。名义上，曝光补偿是相机提供的单独功能，能使得照片变亮与变暗。曝光补偿越大，图片越亮，反之就会越暗。</p><p>下面我拍了两张图片，分别是在不同曝光补偿的情况下拍摄的。可以明显地看到两张图片的色彩有明显差异。可我们在快门信息里面，没有看到曝光补偿相关的数据，难道是 Google Pixel 偷懒吗？实际上，曝光补偿只是一个语法糖，相机会根据你的曝光需求，动态地调整「快门」+「光圈」+「感光度」，已达到发亮的效果。所以快门信息里面，可以没有曝光补偿，而且有了了曝光补偿会更容易发生误解，快门、感光度这些信息是补偿前的，还是补偿后的？</p><blockquote><p>世上本没有曝光补偿，调节亮度的需求多了，也就有了曝光补偿。</p></blockquote><p><img src="https://i.loli.net/2018/11/10/5be6375485897.png" alt="不同曝光补偿下的照片"><br><img src="https://i.loli.net/2018/11/10/5be6375534d68.png" alt="不同曝光补偿下的照片"></p><p>两张图片，快门信息分别是，F1.8 1/125 4.46mm ISO118，F1.8 1/120 4.46mm ISO325。个人猜想在手机上，调整曝光补偿，大体上都是控制感光度来实现的吧。</p><p>录制了一个简单的视频，来展示曝光补偿对照片产生的变化。</p><p><del>此处有视频演示，微信公众号上传视频真麻烦，有兴趣的童鞋微信联系…</del></p><hr><h2 id="色温-白平衡"><a href="#色温-白平衡" class="headerlink" title="色温(白平衡)"></a>色温(白平衡)</h2><p>设想一下，我们坐在火炉旁烤火，期初的时候温度较低，炉火的颜色偏红，而后温度逐渐升高，炉火逐渐偏蓝，似乎看起来颜色表现出了的色值与问题的温度有关。根据维基百科上的描写，一标准黑体加热，温度升高到一定程度时颜色变化，称为色温。由于在定义的时候，是将标准黑体进行加热，发生颜色变化，这里就沿用了开尔文单位(K)来表达色温。</p><p><img src="https://i.loli.net/2018/11/10/5be6378b4d8ed.png" alt="色温图"></p><p><strong>::色温越高，颜色越偏蓝，反正越偏红::</strong>。</p><p>下面的图来自于<a href="https://zhuanlan.zhihu.com/p/26899270" target="_blank" rel="noopener">摄影入门之白平衡 - 知乎</a>，下面两张图分别是在高色温(阴天)和低色温(黄昏)情况下的图片。阴天情况下，冷光更多地折射下来，颜色偏蓝，由此色温更高。在黄昏的时候，暖光会相对更多，颜色偏黄，色温也就更低些。</p><p><img src="https://i.loli.net/2018/11/10/5be637aa9726d.png" alt="高色温"><br><img src="https://i.loli.net/2018/11/10/5be637ab0e61b.png" alt="低色温"></p><p>讲到这里，就继续说明下白平衡啦~ 我们人眼是可以自行脑补各种色温的，但相机不行，分辨不出是在何种光源下进行的拍摄。那么告诉相机当前所处于哪种光源，相机矫正色温，这就是白平衡。</p><p>下面的视频演示的是，三星 Note8 设置白平衡的视频。视频中，可以看到 K 值越小，显示出来的视频越蓝。(这里K值是告诉相机当前所处的色温值，K值越小，就越得向色温高的方向进行补偿，因而画面会偏蓝)</p><p><del>此处有视频演示，微信公众号上传视频真麻烦，有兴趣的童鞋微信联系…</del></p><hr><h2 id="HDR-模式"><a href="#HDR-模式" class="headerlink" title="HDR 模式"></a>HDR 模式</h2><p>High-Dynamic Range，高动态范围。听上去很玄学，实际上并不复杂。HDR 模式其实并不是什么拍摄技术，而是后期技术。</p><p>我们在拍照的时候，对于初学者而言，往往很难去应付复杂的光线环境。例如逆光拍摄，夜景拍摄等等，很容易拍摄出过曝，或者太黑的照片。有没有什么傻瓜的方法了？有呀，答案就是小标题鸭 - HDR。</p><p>上面这句话，有问题。HDR模式，通过多张照片整合，能达到自然光线所不能达到的雨露均沾的效果。</p><blockquote><p>HDR技术则通过拍摄多张不同曝光度的照片，从而让综合亮度层次远远超出原来的限制，这样过曝的照片可以弥补暗部的细节缺失，欠曝可以将高光的地方完美呈现。( <del>为什么别人总能表达得这么清晰，而我就像白水话一样，对不起迅哥呀</del> )</p></blockquote><p><img src="https://i.loli.net/2018/11/10/5be6390a6946d.png" alt="HDR和非HDR模式的对比"></p><p>上面两张图片，是在华为 Honor P20 手机上拍摄的。分别是启用了 HDR 模式和关闭 HDR 模式上拍摄的。</p><hr><p>现在手机已经很强大了，不同于胶片时代，我们已经能很轻松地拍出一张曝光正确的照片了。前面提及的背景知识、小技巧，都只是辅助，拍照永远是你在那一块对光影的看法。</p><p>末了、渐渐地抛出，相机的真正四要素。</p><ul><li><input disabled type="checkbox"> 合适的构图</li><li><input disabled type="checkbox"> 特殊的光影</li><li><input disabled type="checkbox"> 富有故事性</li><li><input disabled type="checkbox"> 独特创造力</li></ul><p>我们来看看利用前面的知识可以做出什么样的效果。<br><img src="https://i.loli.net/2018/11/10/5be639634daec.png" alt="C7BDBE38-5185-4382-9E36-110EC3BABA78.png"><br><img src="https://i.loli.net/2018/11/10/5be639639e86a.png" alt="99614653-3892-44F5-A624-175401807715.png"><br><img src="https://i.loli.net/2018/11/10/5be63963b6af6.png" alt="150B419E-7C86-4B7D-B8B9-9C77A48D2F06.png"><br><img src="https://i.loli.net/2018/11/10/5be63963d6036.png" alt="A65C8A51-0FB5-4F4B-B182-0B48BC0C3EE7.png"><br><img src="https://i.loli.net/2018/11/10/5be6396496261.png" alt="1F09F3C4-8F04-4065-99B5-35CCF5533E73.png"></p><p>祝大家，拍得愉快，拍得开心~</p><p>撒花 ！！！</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.quora.com/How-does-a-mobile-camera-work" target="_blank" rel="noopener">How does a mobile camera work? - Quora</a></li><li><a href="https://youtu.be/gZ_KP2NO_bk" target="_blank" rel="noopener">Behind the lens of a 41MP Nokia Lumia 1020 - YouTube</a> 一个手机拍摄成像的流程视频，当然需要翻墙(手动扇子脸)</li><li><a href="https://www.zhihu.com/question/22430557" target="_blank" rel="noopener">景深的原理是什么？ - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/35700847" target="_blank" rel="noopener">单反光圈、焦距与景深的关系 - 知乎</a></li><li><a href="http://blog.xieyc.com/depth-of-field-and-hyperfocal-distance/" target="_blank" rel="noopener">相机对焦原理（附景深与超焦距） | 小谢的小站</a></li><li><a href="https://zhuanlan.zhihu.com/p/29146281" target="_blank" rel="noopener">摄影入门之测光模式和应用 - 知乎</a></li><li><a href="https://en.wikipedia.org/wiki/Metering_mode" target="_blank" rel="noopener">Metering mode - Wikipedia</a></li><li><a href="https://zhuanlan.zhihu.com/p/21650705" target="_blank" rel="noopener">玩转对焦，手机能当相机用！ - 知乎</a></li><li><a href="https://107cine.com/m/mstream/90935/" target="_blank" rel="noopener">玩转18%灰</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2018年11月10日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      这篇文章将重点介绍了，照片背后的原理
    
    </summary>
    
    
      <category term="camera" scheme="http://www.woaitqs.cc/categories/camera/"/>
    
    
      <category term="photo" scheme="http://www.woaitqs.cc/tags/photo/"/>
    
      <category term="wb" scheme="http://www.woaitqs.cc/tags/wb/"/>
    
      <category term="focus" scheme="http://www.woaitqs.cc/tags/focus/"/>
    
      <category term="camera" scheme="http://www.woaitqs.cc/tags/camera/"/>
    
  </entry>
  
  <entry>
    <title>Android View 全解析(五) -- 实践自定义 View</title>
    <link href="http://www.woaitqs.cc/2016/11/28/2016-11-28-android-view-theory-5/"/>
    <id>http://www.woaitqs.cc/2016/11/28/2016-11-28-android-view-theory-5/</id>
    <published>2016-11-28T08:52:50.000Z</published>
    <updated>2019-07-26T15:52:45.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="确定自定义的样式"><a href="#确定自定义的样式" class="headerlink" title="确定自定义的样式"></a>确定自定义的样式</h2><p>在前面的<a href="http://www.woaitqs.cc/android/2016/10/10/android-view-theory-1.html">系列文章</a>之后,大家已经对 View 绘制中的各个过程熟悉了，这篇文章就根据前面所学的知识，来实际动手做一个自定义 View，这也是整个系列的完结篇了，会尽可能地涵盖自定义 View 中的各个方面，以及可能遇到的各种坑。在经过一番考量后，决定使用一个 PagerIndicator 作为例子进行讲解。在开始后面的文章之前，建议 Clone 下 <a href="https://github.com/woaitqs/FPageIndicator" target="_blank" rel="noopener">https://github.com/woaitqs/FPageIndicator</a>，对照着源码阅读，食用效果更佳。</p><p>最后我们需要实现的效果如图所示：</p><p><img src="https://cloud.githubusercontent.com/assets/1680722/20701135/42297c0a-b64c-11e6-8eea-ab706946af90.gif" alt="样式展示"></p><p>一般情况下，我们需要自定义 View 的时候，都要考量有哪些地方需要自定义的，对于上图的情况，可以认为选中和未选中的颜色是可以自定义的，大圈和小圈的自定义也是可以自定义的，还有诸如间距等等这些也是可以的。为了使开发者在使用的时候，能够在 XML 文件中也能进行自定义，我们需要声明 <code>styleable</code> 文件，<a href="https://developer.android.com/training/custom-views/create-view.html" target="_blank" rel="noopener">官方教程</a> 有详细说明如何进行属性定义。</p><p>对于上图的例子，可以写如下的<code>styleable</code> 文件。建议自定义的属性上，添加上同一的前缀，这样更容易区分开来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"PageIndicator"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"pi_count"</span> <span class="attr">format</span>=<span class="string">"integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"pi_out_radius"</span> <span class="attr">format</span>=<span class="string">"dimension"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"pi_radius"</span> <span class="attr">format</span>=<span class="string">"dimension"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"pi_un_focus_color"</span> <span class="attr">format</span>=<span class="string">"color"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"pi_focus_color"</span> <span class="attr">format</span>=<span class="string">"color"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"pi_padding"</span> <span class="attr">format</span>=<span class="string">"dimension"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么如何在自定义的 View 中，将这些设置进去的属性取出来呢？这时候我们要用到 TypedArray，通过这个能属性从 AttributeSet 取出来，同时也需要注意在用户没有设置自定义属性时的默认值。代码也相对很简单，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAttributes</span><span class="params">(AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (attrs == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.PageIndicator);</span><br><span class="line">  count = typedArray.getInteger(R.styleable.PageIndicator_pi_count, <span class="number">1</span>);</span><br><span class="line">  outRadius = typedArray.getDimension(R.styleable.PageIndicator_pi_out_radius,</span><br><span class="line">      dpToPx(DEFAULT_OUT_RADIUS_SIZE));</span><br><span class="line">  innerRadius = typedArray.getDimension(R.styleable.PageIndicator_pi_radius,</span><br><span class="line">      dpToPx(DEFAULT_INNER_RADIUS_SIZE));</span><br><span class="line">  unFocusColor = typedArray.getColor(R.styleable.PageIndicator_pi_un_focus_color,</span><br><span class="line">      Color.parseColor(DEFAULT_UN_FOCUS_COLOR));</span><br><span class="line">  focusColor = typedArray.getColor(R.styleable.PageIndicator_pi_focus_color,</span><br><span class="line">      Color.parseColor(DEFAULT_FOCUS_COLOR));</span><br><span class="line">  padding = typedArray.getDimension(R.styleable.PageIndicator_pi_padding, <span class="number">0F</span>);</span><br><span class="line">  typedArray.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="初始化相应属性"><a href="#初始化相应属性" class="headerlink" title="初始化相应属性"></a>初始化相应属性</h2><p>在构造函数或者 attachToWindow 的时候，就初始化自定义 View 中可能用到的各种变量，例如 Paint，而不是在使用时，再去构造。因为诸如 onMeasure、onDraw 方法可能会被多次调用，频繁地分配对象，可能会引起内存抖动。内存抖动会在短时间内触发多次 GC 操作，从而引起卡顿。我在这篇文章中，<a href="http://www.woaitqs.cc/android/2016/03/30/in-love-with-android-memory">http://www.woaitqs.cc/android/2016/03/30/in-love-with-android-memory</a> 说明了这种情况是如何发生的。</p><p>对于本文的情况，初始化 Paint 就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  innerUnFocusPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">  innerUnFocusPaint.setColor(unFocusColor);</span><br><span class="line"></span><br><span class="line">  innerFocusPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">  innerFocusPaint.setColor(focusColor);</span><br><span class="line"></span><br><span class="line">  outPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">  outPaint.setColor(focusColor);</span><br><span class="line">  outPaint.setStrokeWidth(<span class="number">2F</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="重载-onMeasure-方法"><a href="#重载-onMeasure-方法" class="headerlink" title="重载 onMeasure 方法"></a>重载 onMeasure 方法</h2><p>onMeasure 方法是让 view 自身测量自己的大小，这是关键步骤。分为两种情况，继承自 ViewGroup 的，还是继承自 View 。如果是 ViewGroup 的话，需要在合适的地方，让子 View 测量后，再得到自身的大小。而如果是 View，则只需管好自己的大小即可。</p><p>MeasureSpec 是 onMeasure 方法中参数的类型，它通过位运算的方式，涵盖了模式和大小两个数据，通过 getMode 和 getSize 可以分别得到模式和大小。这是要特别针对模式进行说明，如果模式为 EXACTLY，说明 View 的大小是指定了的，那么就使用传入的指即可。如果是 AT_MOST, 那么就得先计算出预期的大小。预期的大小，是指在不考虑外界的情况下，View 所占据的大小，对于本文的例子，预期的大小就是几个圈的大小加上它们之间的间距。在计算之后，与指定的大小取两者最小的。如果是 UNSPECIFIED 的情况，那说明父类对你的大小没有预期，那就使用预期的大小即可。下面的代码是一个很清晰的说明。</p><p>最后一定不要忘记，调用 setDimension 方法哦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">  width = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">  width = Math.min(desiredWidth, widthSize);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  width = desiredWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多知识，参考 <a href="http://www.woaitqs.cc/2016/10/18/android-view-theory-2">http://www.woaitqs.cc/2016/10/18/android-view-theory-2</a>.</p><hr><h2 id="重载-onDraw-方法"><a href="#重载-onDraw-方法" class="headerlink" title="重载 onDraw 方法"></a>重载 onDraw 方法</h2><p>onDraw 方法就更为简单了，只是简单地对 Canvas 提供的 API 进行调用。在调用时，一定要对 Android 的坐标系非常清楚才行，知道哪里是 X 轴，哪里是 Y 轴，left，right，top 和 bottom 是相对于哪里的距离。</p><p>只要计算好每个绘制 View 的坐标，再调用相应的 API 就能看到效果了！Cheers！下面的代码，就绘制了选中和未选中的几个点。再强调下，这里使用的 Paint 是提前初始化完成的哦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">  canvas.drawCircle(</span><br><span class="line">      outRadius - innerRadius + padding * i + innerRadius * (<span class="number">1</span> + <span class="number">2</span> * i),</span><br><span class="line">      height / <span class="number">2</span>,</span><br><span class="line">      innerRadius,</span><br><span class="line">      i == selectedPos ? innerFocusPaint : innerUnFocusPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义 onDraw 的时候，设计的宗旨是保持无状态性，也就是说，onDraw 是对每一个时刻状态的投诉，例如本例子，就应该是某个滑动时刻的投射。如果在 onDraw 中进行动画，或者起一些异步线程等等，会使得代码的可读性变差。</p><hr><h2 id="View-的更新策略"><a href="#View-的更新策略" class="headerlink" title="View 的更新策略"></a>View 的更新策略</h2><p>写完自定义 View 后，还得在用户更改属性后或者其他事件后，相应地让 View 更新下。</p><blockquote><p>requestLayout.<br>会触发 ViewRoot 的 performTraversal方法，从而重新执行 Measure、Layout，在特定情况下会触发 Draw 操作。</p></blockquote><blockquote><p>invalidate.<br>会触发 Draw 操作，如果 View 的大小和位置没有发生改变，调用这个方法就足以更新页面了。</p></blockquote><p>在本文的例子里面，当用户滑动 ViewPager 时，View 的大小和位置不会发生改变，因而调用 invalidate 就足够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">  drawPosition = position;</span><br><span class="line">  drawPositionOffset = positionOffset;</span><br><span class="line">  invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个系列结束，有兴趣的同学，可以 Clone <a href="https://github.com/woaitqs/FPageIndicator" target="_blank" rel="noopener">https://github.com/woaitqs/FPageIndicator</a>这个项目来进行探讨 ：）。</p><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年11月28日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      手把手教你自定义 View
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/tags/android/"/>
    
      <category term="view" scheme="http://www.woaitqs.cc/tags/view/"/>
    
  </entry>
  
  <entry>
    <title>Android View 全解析(四) -- onDraw</title>
    <link href="http://www.woaitqs.cc/2016/10/28/2016-10-28-android-view-theory-4/"/>
    <id>http://www.woaitqs.cc/2016/10/28/2016-10-28-android-view-theory-4/</id>
    <published>2016-10-28T08:52:50.000Z</published>
    <updated>2019-07-26T15:18:35.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>在前面介绍了 <a href="http://www.woaitqs.cc/android/2016/10/18/android-view-theory-2.html">onMeasure</a> 用于确定 view 大小，<a href="http://www.woaitqs.cc/android/2016/10/25/android-view-theory-3.html">onLayout</a> 用于确定 view 的位置后，最后我们看看三大事件中最后压轴出场的 onDraw，这确定了 view 长什么模样。</p><p>onDraw 相对前面两者，涉及到的知识面非常的广。从 Canvas 提供的种类繁多的 API，到 Paint、Path 贝塞尔曲线等等高阶的工具，如果要细讲的话，估计这篇文章就得老长老长了。在这些工具的支持下，圆角按钮、复杂的下拉动画等等都手到擒来。关于这些工具的具体用法，在文末提供一些参考链接，有兴趣的同学可以去学习下。</p><p>onDraw 方法中的参数为 canvas，这个类型为 <a href="https://developer.android.com/reference/android/graphics/Canvas.html" target="_blank" rel="noopener">Canvas</a> 的实例，就是我们主要操作的对象。中文意思为画布，也很形象哈，onDraw 就是在画布上将东西画上去。那么既然是把内容画上去，那么第一件事情就是要有一个画笔。Android 提供了这样的工具，也就是 <a href="https://developer.android.com/reference/android/graphics/Paint.html" target="_blank" rel="noopener">Paint</a> 类。</p><p>Paint 提供了一些常用的 API，用于自定义画笔。</p><table><thead><tr><th>方法名</th><th align="center">含义</th></tr></thead><tbody><tr><td>setColor</td><td align="center">设置画笔的颜色</td></tr><tr><td>setStrokeWidth</td><td align="center">画笔的宽度</td></tr><tr><td>setStyle</td><td align="center">画笔的类型（实心、空心、描边）</td></tr><tr><td>setShader</td><td align="center">设置着色器 (渐变等效果)</td></tr></tbody></table><p>接下来绘制一个正菱形。绘制菱形的话，可以直接画上去，但需要考虑角度等等复杂问题，有一个更讨巧的方法是先绘制一个正方形，然后以某个角为原点，旋转45度即可 ：）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setColor(Color.RED);</span><br><span class="line">paint.setStyle(Paint.Style.FILL);</span><br><span class="line">paint.setStrokeWidth(<span class="number">10F</span>);</span><br><span class="line"><span class="comment">// 以上代码，最好在构造函数时就完成，不要在 onDraw 方法时调用</span></span><br><span class="line"><span class="comment">// 否则会引起内存抖动。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制正方形</span></span><br><span class="line">canvas.drawRect(<span class="number">200</span>, <span class="number">200</span>, <span class="number">400</span>, <span class="number">400</span>, paint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制菱形，为了区分，修改下颜色</span></span><br><span class="line">paint.setColor(Color.BLUE);</span><br><span class="line"><span class="comment">// 将坐标原点移动到顶点上</span></span><br><span class="line">canvas.translate(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 以坐标原点为中心，进行旋转</span></span><br><span class="line">canvas.rotate(<span class="number">45</span>);</span><br><span class="line"><span class="comment">// 绘制菱形</span></span><br><span class="line">canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, paint);</span><br></pre></td></tr></table></figure><hr><h2 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h2><p>首先我们绘制一个简单的背景图，这也是 Canvas 提供的基础功能，包含有重载的多个 drawBitmap 接口。如果没有什么特殊需求，可以调用 drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint) 方法。简单的示例代码如下，这样图片就出现在画布的左上角了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bgBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.spring);</span><br><span class="line">canvas.drawBitmap(bgBitmap, <span class="keyword">new</span> Matrix(), <span class="keyword">new</span> Paint());</span><br></pre></td></tr></table></figure><p>接下来，我们尝试再画一个三角形，学习如何绘制路径。绘制与路径相关的内容，需要用到 Path 这个工具。Path 有许多高阶的用法，例如贝塞尔曲线，在接下来的章节中将简单地进行叙述，这里先只绘制直线。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setStrokeWidth(<span class="number">10F</span>);</span><br><span class="line">paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">paint.setColor(Color.BLACK);</span><br><span class="line">paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line"></span><br><span class="line">Path path = <span class="keyword">new</span> Path();</span><br><span class="line">path.lineTo(<span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">path.lineTo(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">path.close();</span><br><span class="line"></span><br><span class="line">canvas.drawPath(path, paint);</span><br></pre></td></tr></table></figure><p>path 关于直线的操作，主要是两个 moveTo 和 lineTo，moveTo 移动下一次绘制操作开始的起点，例如 moveTo(20,20)，那么下一次操作就从(20,20) 这里开始。而 lineTo 就更加直接一点，直接在设定的起点(默认为(0,0))开始，到指定的结束为止绘制一条直线。</p><p>在一些参考博客中, 发现他们在 onDraw 中通过绘制不同的 Path 来达到动画的效果，再通过 handler postMessage 的方式来进行动画步骤时间的分配。但我不是很推荐这样的做法，这种情况下 onDraw 方法承担了太多的责任，动画的逻辑应该和这个区分开来。其实 Android 本身提供的动画机制以外，还有 AnimationDrawable 这个很方便的工具来通过 xml 来实现动画。</p><p>代码实现主要是三个 XML 文件，其中这里使用了 Vector(矢量图)(有兴趣的同学可以看看这个<a href="https://developer.android.com/studio/write/vector-asset-studio.html" target="_blank" rel="noopener">链接</a>)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:width</span>=<span class="string">"18dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:height</span>=<span class="string">"9dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportHeight</span>=<span class="string">"9"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:viewportWidth</span>=<span class="string">"18"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"bird"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:pathData</span>=<span class="string">"M2,4c3,-1 6,-1.5 7,2c1,-3.5 4,-3 7,-2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:strokeColor</span>=<span class="string">"#20416b"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:strokeLineCap</span>=<span class="string">"round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:strokeLineJoin</span>=<span class="string">"round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:strokeMiterLimit</span>=<span class="string">"1.41421"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:strokeWidth</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectAnimator</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:propertyName</span>=<span class="string">"pathData"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:repeatCount</span>=<span class="string">"infinite"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:repeatMode</span>=<span class="string">"reverse"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueFrom</span>=<span class="string">"M2,4c3,-1 6,-1.5 7,2c1,-3.5 4,-3 7,-2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueTo</span>=<span class="string">"M4,7c3,-1 4,-4.5 5,-1c1,-3.5 2,0 5,1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:valueType</span>=<span class="string">"pathType"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animated-vector</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:drawable</span>=<span class="string">"@drawable/bird_up_and_down"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"bird"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:animation</span>=<span class="string">"@animator/fly"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animated-vector</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p>前面提到 Path 可以表达直线和曲线(实际上直线也是曲线的一种)，曲线千变万化，东绕西拐的，有没有一种方式可以去涵盖所有的平面曲线了？有的，答案就是<code>贝塞尔曲线</code>。</p><blockquote><p>贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau演算法开发，以稳定数值的方法求出贝兹曲线。<br>在计算机图形学中贝赛尔曲线的运用也很广泛，Photoshop中的钢笔效果，Flash5的贝塞尔曲线工具，在软件GUI开发中一般也会提供对应的方法来实现贝赛尔曲线。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaveView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STEP = <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAVE_LENGTH = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_OFFSET = <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WaveView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WaveView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">WaveView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    <span class="keyword">final</span> ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    executorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getHandler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (offset &gt; MAX_OFFSET) &#123;</span><br><span class="line">              offset = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            offset += STEP;</span><br><span class="line">            invalidate();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">300</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">    paint.setStrokeWidth(<span class="number">5F</span>);</span><br><span class="line">    paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    paint.setColor(Color.BLUE);</span><br><span class="line">    paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line"></span><br><span class="line">    Path path = <span class="keyword">new</span> Path();</span><br><span class="line">    path.moveTo(offset, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> randomHeight = <span class="keyword">new</span> Random().nextInt(<span class="number">50</span>) + <span class="number">50</span>;</span><br><span class="line">      path.cubicTo(</span><br><span class="line">          (i + <span class="number">1F</span> / <span class="number">3</span>) * WAVE_LENGTH + offset, <span class="number">200</span> - randomHeight,</span><br><span class="line">          (i + <span class="number">2F</span> / <span class="number">3</span>) * WAVE_LENGTH + offset, <span class="number">200</span> + randomHeight,</span><br><span class="line">          (i + <span class="number">1</span>) * WAVE_LENGTH + offset, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.drawPath(path, paint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也是非常的简单，首先通过 cubicTo 生成波浪，cubic 函数中的前两个函数分别是两个控制点，我们将两个控制点分别置于水平线上下两个地方，这样就能生成一条波浪线。其次在使得每次波浪都便宜固定值，形成涌动的效果。最后为了一个更好的效果，给波浪振动的高度上加上一个随机数。</p><p>贝塞尔曲线能提供的功能原不只这些，更多姿势大家就自行解锁了哦 ：）</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">http://www.gcssloop.com/customview/CustomViewIndex</a></li><li><a href="https://developer.android.com/training/custom-views/custom-drawing.html" target="_blank" rel="noopener">https://developer.android.com/training/custom-views/custom-drawing.html</a></li><li><a href="http://jeremie-martinez.com/2016/09/15/train-animations/" target="_blank" rel="noopener">http://jeremie-martinez.com/2016/09/15/train-animations/</a></li><li><a href="https://developer.android.com/guide/topics/graphics/2d-graphics.html" target="_blank" rel="noopener">https://developer.android.com/guide/topics/graphics/2d-graphics.html</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年11月3日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      android view onDraw 的执行过程
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="view" scheme="http://www.woaitqs.cc/tags/view/"/>
    
      <category term="window" scheme="http://www.woaitqs.cc/tags/window/"/>
    
      <category term="onDraw" scheme="http://www.woaitqs.cc/tags/onDraw/"/>
    
  </entry>
  
  <entry>
    <title>Android View 全解析(三) -- onLayout</title>
    <link href="http://www.woaitqs.cc/2016/10/25/2016-10-25-android-view-theory-3/"/>
    <id>http://www.woaitqs.cc/2016/10/25/2016-10-25-android-view-theory-3/</id>
    <published>2016-10-25T08:52:50.000Z</published>
    <updated>2019-07-26T15:14:25.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Layout-坐标系"><a href="#Layout-坐标系" class="headerlink" title="Layout 坐标系"></a>Layout 坐标系</h2><p>在<a href="http://www.woaitqs.cc/android/2016/10/18/android-view-theory-2.html">上一篇文章</a>中，主要介绍了 onMeasure 的执行过程，这篇文章接着介绍下一个主要节点，onLayout。通过这篇文章的学习，可以了解 onLayout 的工作过程，已经常用的方法。最后以 FrameLayout 的 onLayout 方法来说明一下怎么自定义 onLayout 方法。</p><p>Layout 要完成的工作主要是将 View 放置到合适的位置上去，那么怎么来定义位置呢？在初中数学的时候，我们都学过笛卡尔坐标系，通过 (x,y) 的形式可以定义一个在二维空间的一个点。</p><p>常用的手机屏幕也是二维系的，Android 系统也是通过同样的坐标系来进行定位的，不过与笛卡尔坐标系不同的时候，y 轴的方向是相反的。其实，这也很好理解，Android 手机是往上滑动，内容是从底部慢慢慢慢出现的，将左上角定位成原点，也很自然而然。下面这张图，说明了 Android 手机中的坐标系是怎样的。</p><p><img src="/images/blog/android-position.png" alt="Android 手机坐标系"></p><hr><h2 id="View-和位置相关的常用方法"><a href="#View-和位置相关的常用方法" class="headerlink" title="View 和位置相关的常用方法"></a>View 和位置相关的常用方法</h2><p>开发过程中，我们常用到一些诸如 getTop 的方法，这一小节简单地介绍这些方法，说明他们真正的含义。这里需要补充说明的是，这些方法设计到的单位都是 <code>Pixel</code>，不是 dip 哦。</p><table><thead><tr><th>方法名</th><th align="center">含义</th></tr></thead><tbody><tr><td>getTop</td><td align="center">view左上角与父view之间的距离</td></tr><tr><td>getBottom</td><td align="center">子View右下角距父View顶部的距离</td></tr><tr><td>getLeft</td><td align="center">子View左上角距父View左侧的距离</td></tr><tr><td>getRight</td><td align="center">子View右下角距父View左侧的距离</td></tr></tbody></table><p>下面的图例也说明了这一点。</p><p><img src="/images/blog/android-distance.jpeg" alt="top_bottom_left_right"></p><p>那么我们偶尔用到的 scrollBy(x,y) 和 scrollTo(x,y) 中的 x 和 y 又是啥意思呢？这里的 (x,y) 是相对于父 View 而言的，还是屏幕的左上角呢？答案是前者，有兴趣的读者可以写一个小程序验证一下。scrollBy(x,y) 等价于 scrollTo(posX + x, posY + y)。</p><p>最后一种情况是，我们处理触摸时间的时候，通常会用到 MotionEvent, event 中的 getX 和 getY 方法这样可以知道触摸点的X，Y坐标。这里的 X 和 Y 分别是相对于父 View 而言的，如果想要获得相对于屏幕左上角的坐标可以用 getRawX 和 getRawY 来代替。</p><hr><h2 id="FrameLayout-onLayout-解析"><a href="#FrameLayout-onLayout-解析" class="headerlink" title="FrameLayout onLayout 解析"></a>FrameLayout onLayout 解析</h2><p>前文中，介绍了自定义 onMeasure 方法时，一定要调用 setMeasuredDimension, 对于 onLayout 方法而言，一定要对 view 调用 layout 方法，这样才能将 view 放置到合适的位置上去。layout 方法分别有四个参数，依次是 view 相对于 父view 的左边距，上边距，右边距，和下边距，可以理解为 9 点钟方向开始的顺时针 12 小时，哈哈，很形象吧。这里需要主要的是，右边距不是相对于父 view 的右边界，而是 view 的右边界相对于父 view 的左边界而言的，理解这个可以参考上一个图中所描述的 getRight 和 getBottom。</p><p>FrameLayout 的 onLayout 方法比较简单，这里直接通过注释的形式进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可使用的父 view 的左边界范围，这里的边界是综合考虑了 foreground 和 padding的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="comment">// 右边界。right 和 left 分别是指左右两边的 X 坐标</span></span><br><span class="line">    <span class="comment">// 两者相减，再减去右边的 padding 可以得到父 view 的右边界范围。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与上面类似，就不重复写了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个 view，设置每一个 view 的位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="comment">// 只操作可见 view</span></span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// width 和 height 分别是 Measure 过后的 宽和高</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    <span class="comment">// gravity 是水平居中的情况</span></span><br><span class="line">                    <span class="comment">// 左坐标的计算可以分为两部分</span></span><br><span class="line">                    <span class="comment">// 1. 可使用的父 view 的左边界范围 + 放置view的中间位置(父view可用范围 减去 view 宽度后的一半)</span></span><br><span class="line">                    <span class="comment">// 2. 移除右 margin 加上 左margin</span></span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="comment">// 这里主要考虑的是强制从左排列，在开发者选项中可以进行设置。</span></span><br><span class="line">                    <span class="comment">// 这里就先不讨论这个。</span></span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 默认情况，加上左 margin 就行。</span></span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    <span class="comment">// 垂直居中的情况，与上面类似，也不重复了。</span></span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最重要的地方，将计算得出的四个位置作为参数，设置进去。</span></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年10月26日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      android view onLayout 的执行过程
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="view" scheme="http://www.woaitqs.cc/tags/view/"/>
    
      <category term="window" scheme="http://www.woaitqs.cc/tags/window/"/>
    
      <category term="onLayout" scheme="http://www.woaitqs.cc/tags/onLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android View 全解析(二) -- OnMeasure</title>
    <link href="http://www.woaitqs.cc/2016/10/18/2016-10-18-android-view-theory-2/"/>
    <id>http://www.woaitqs.cc/2016/10/18/2016-10-18-android-view-theory-2/</id>
    <published>2016-10-18T08:52:50.000Z</published>
    <updated>2019-07-26T15:10:15.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MeasureSpec-的定义与实现"><a href="#MeasureSpec-的定义与实现" class="headerlink" title="MeasureSpec 的定义与实现"></a>MeasureSpec 的定义与实现</h2><p>在<a href="http://www.woaitqs.cc/2016/10/10/android-view-theory-1.html">上篇文章</a>中，介绍了 view 与窗口系统的关系，以及在这个系统中是怎么触发 View 的三类重要事件的。接下来说说，三类事件中 onMeasure 事件，并以 FrameLayout 的 onMeasure 为例详细说明 measure 过程是如何进行的。</p><p>首先先看看 performTraversals 里是如何进行 Measure 过程的。由于这个方法代码繁多，这里只展示与 Measure 过程相关的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br></pre></td></tr></table></figure><p>首先说明一下这里的 MeasureSpec 是什么，这里是利用了位运算，将一个 int 类型包含了两种信息，分别是 size 和 mode。java 的 int 类型，可以表示 32 位数字，最高的两位数字用来表示 mode，其余的部分用来表示 size。对于手机屏幕而言，size 一般都优先，不用担心需要 31 位数字来表达 size 的情况。</p><p>MeasureSpec 分别有三种 mode，分别是 UNSPECIFIED, EXACTLY 和 AT_MOST.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has not imposed any constraint</span></span><br><span class="line"><span class="comment"> * on the child. It can be whatever size it wants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The parent has determined an exact size</span></span><br><span class="line"><span class="comment"> * for the child. The child is going to be given those bounds regardless</span></span><br><span class="line"><span class="comment"> * of how big it wants to be.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Measure specification mode: The child can be as large as it wants up</span></span><br><span class="line"><span class="comment"> * to the specified size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure><p>UNSPECIFIED: 标明自身对 View 大小没有任何限制，需要子 View 的信息来帮助协定</p><p>EXACTLY: View 已经确定自身的大小</p><p>AT_MOST: 父 View 已经限定了最大大小，具体 View 能不能超过这个限制，得看不同 View 的实现情况。</p><p>而对于 Size 而言，就是具体的数值大小了。Android 提供了生成 MeasureSpec 的静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们知道了 MeasureSpec 可以用来表征一个 View 的大小信息，接下来的章节看看，这些信息是如何应用的。</p><hr><h2 id="DecorView-的-MeasureSpec"><a href="#DecorView-的-MeasureSpec" class="headerlink" title="DecorView 的 MeasureSpec"></a>DecorView 的 MeasureSpec</h2><p>回到最开始的代码片段，我们看看 getRootMeasureSpec 是如何实现的，通过这个方法我们就可以知道 DecorView 是如何定义自己的大小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到 DecorView 的大小是与 Window 的大小和 layoutParams 相关的，如果是 MATCH_PARENT, 那么 DecorView 的 MeasureSpec 就是精确的 Window 大小。接下来看看 windowSize， rootDimension 是怎么赋值的？我这里直接贴代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowManager.LayoutParams mWindowAttributes = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">    type = TYPE_APPLICATION;</span><br><span class="line">    format = PixelFormat.OPAQUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到默认情况下，window 的 LayoutParams 就是 MATCH_PARENT, 这样 DecorView 的大小就是 Window 的大小。</p><hr><h2 id="View-的-Measure-实现"><a href="#View-的-Measure-实现" class="headerlink" title="View 的 Measure 实现"></a>View 的 Measure 实现</h2><p>接着看最开始代码中 performMeasure 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中执行到了 View 的 Measure 方法里面。注意到下面的代码签名，使用了 final 关键字，这样任何继承自 View 的类都不能复写这个方法，因为在这个类中涉及到了 Measure 的重要流程，如果这个过程被打断，那么会导致整个流程失败，因而这里添加 final 关键字是很有必要的。代码中还省略了部分与缓存相关的代码，代码中的重点在于 <code>onMeasure</code> 这个方法，一定要在这个方法中，指定 MeasureSpec，否则就不能知道 view 的大小了，后续的步骤也不能继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Suppress sign extension for the low bytes</span></span><br><span class="line">        <span class="keyword">long</span> key = (<span class="keyword">long</span>) widthMeasureSpec &lt;&lt; <span class="number">32</span> | (<span class="keyword">long</span>) heightMeasureSpec &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">                widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">                heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                    mMeasureCache.indexOfKey(key);</span><br><span class="line">            <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">                <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">                onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line">            <span class="comment">// an exception to warn the developer</span></span><br><span class="line">            <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></span><br><span class="line">                        + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></span><br><span class="line">                        + <span class="string">" measured dimension by calling"</span></span><br><span class="line">                        + <span class="string">" setMeasuredDimension()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们先看看 onMeasure 的默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认实现而言，如果 View 的 mode 仍旧为 UNSPECIFIED，将其指定为最小size(可以人为指定，否则为0，或者背景的最小值)，否则为 measureSpec 中指定的大小。</p><hr><h2 id="ViewGroup-的-Measure-实现"><a href="#ViewGroup-的-Measure-实现" class="headerlink" title="ViewGroup 的 Measure 实现"></a>ViewGroup 的 Measure 实现</h2><p>相对复杂的是 ViewGroup，ViewGroup 继承自 View，但 View 的 measure 方法是 final 的，ViewGroup 需要自定义 measure 过程时就得复写 onMeasure 方法。每个 ViewGroup 的需求不同，很难统一起来讲，这里以 FrameLayout 为例，讲述它的 Measure 过程，毕竟这是几个官方 ViewGroup 中最简单的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否高或者宽位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    <span class="comment">// 清除原有保留的对象</span></span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个 view</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="comment">// 如果高宽位置，或者 child 是可见的，那么就需要对 child 进行 measure</span></span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">// 调用这个方法时，会让 child 自身进行测量</span></span><br><span class="line">            <span class="comment">// 参数中的两个 0，表示父 Parent 已经占用的空间，这里为 0</span></span><br><span class="line">            <span class="comment">// widthMeasureSpec 和 heightMeasureSpec 分别是父 Parent 的 高宽 MeasureSpec</span></span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 经过 Measure 过程后，就能知道自己的 LayoutParams</span></span><br><span class="line">            <span class="comment">// LayoutParams 含有了自己的宽高信息</span></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">// 更新最大宽度</span></span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            <span class="comment">// 更新最大高度</span></span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            <span class="comment">// 不是很懂这句话... 逃 ：）</span></span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    <span class="comment">// 要对 MatchParent 的做特殊处理，下面的代码可以看到</span></span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account for padding too</span></span><br><span class="line">    <span class="comment">// 加上前景的上下左右 padding</span></span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">    <span class="comment">// 与设定的最大和最小做校验</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">    <span class="comment">// 前景的最小高宽</span></span><br><span class="line">    <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置自身的 measureSpec</span></span><br><span class="line">    <span class="comment">// resolveSizeAndState 是 view 提供的静态方法，返回对应的 measureSpec</span></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每个 LayoutParams 中含有 MATCH_PARENT 的情况。</span></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">// // MATCH_PARENT 的宽度设置为最大宽度</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回其默认的情况</span></span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分代码都通过注释精选了说明，这里就自定义 View 中常用的几个 static 方法进行简单的说明，方便读者有一个大题的认识。</p><ul><li><p><code>measureChildWithMargins</code><br>要求 child 进行 Measure，在绘制的时候将自己的 padding 和 margins 考虑进去。经过 Measure 过后，可以得到对应的 LayoutParams<br>这个方法要求 child 必须得是 MarginLayoutParams，大部分的容器 View (LinearLayout、FrameLayout等等)都是这个 MarginLayoutParams.</p></li><li><p><code>measureChild</code><br>这个方法与前面这个是相对的，不同之处在于只考虑自身的 padding，不考虑 margin。</p></li><li><p><code>measureChildren</code><br>对所有可见 view 调用 measureChild 方法。</p></li><li><p><code>getChildMeasureSpec</code><br>这个是上述方法都会调用的方法，分别有三个参数，当前view的measureSpec, 当前view 的 padding(或者加上margin), 当前 view 期望的大小(不一定会实现)。</p></li></ul><p>方法根据特定的规则来返回对应的 MeasureSpec，这是蔚为重要的一个方法。对应的规则简单如下：</p><p><img src="/images/blog/child-measure.png" alt="child-measure"></p><hr><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol><li><a href="http://ezio.farbox.com/post/android-view-measure-1" target="_blank" rel="noopener">http://ezio.farbox.com/post/android-view-measure-1</a></li><li><a href="http://www.liaohuqiu.net/posts/how-does-android-caculate-the-size-of-child-view/" target="_blank" rel="noopener">http://www.liaohuqiu.net/posts/how-does-android-caculate-the-size-of-child-view/</a></li><li><a href="http://blog.qiji.tech/archives/7740" target="_blank" rel="noopener">http://blog.qiji.tech/archives/7740</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年10月18日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      android view OnMeasure 的执行过程
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="view" scheme="http://www.woaitqs.cc/tags/view/"/>
    
      <category term="window" scheme="http://www.woaitqs.cc/tags/window/"/>
    
      <category term="OnMeasure" scheme="http://www.woaitqs.cc/tags/OnMeasure/"/>
    
  </entry>
  
  <entry>
    <title>Android View 全解析(一) -- 窗口管理系统</title>
    <link href="http://www.woaitqs.cc/2016/10/10/2016-10-10-android-view-theory-1/"/>
    <id>http://www.woaitqs.cc/2016/10/10/2016-10-10-android-view-theory-1/</id>
    <published>2016-10-10T08:52:50.000Z</published>
    <updated>2019-07-26T15:02:24.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窗口管理系统大家族"><a href="#窗口管理系统大家族" class="headerlink" title="窗口管理系统大家族"></a>窗口管理系统大家族</h2><p>一直在写 Android Framework 层的东西，虽然很重要，但一直写这方面的内容，还是有些不够接地气。思前想后一番后，打算写写关于 View 这个在 Android 中平常得不能更平常的东西。由浅入深，仔细梳理，帮助我，也希望能帮助你，更好地再次认识 View。</p><p>第一篇文章主要讲 Android 的窗口管理系统，依托于这套系统，我们才能将 View 显示到屏幕上。了解这套系统，有助于更好地理解 Android View 的来龙去脉。但这个系统复杂，涉及到的方面众多，在这里也只是简述，还望见谅。</p><p>这个小节，主要说一下家族里面的成员，分别是 <code>view</code>,<code>window</code>,<code>windowmanager</code>,<code>viewRoot</code>。小节里面主要介绍它们是什么，以及互相之间的关系是什么。</p><p>在谈及 View 之前，必须得说说 Window 这个东西，通常我们认为显示在界面上的是 View，这么说本身没有什么问题，但更准确的说法是 WindowManager 通过 ViewRoot 将 View 和 Window 协同整合在一起，最终将 View 展示在 Window 上面。正如 Window 这个名字，就是窗口的意思，我们所见的所有东西都要展示在 Window 上，熟知的 Dialog、Activity 以及 Toast 都是展示在 Window 上面的。</p><p>Window 本身是一个抽象类，提供了对标准 UI 行为的一些支持，例如背景、标题栏和按键等等。我们使用的是它的子类，也是唯一的实现 PhoneWindow。</p><p>Window的显示有多种类型，具体可以在 <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html" target="_blank" rel="noopener">这里</a>看到。普通开发的应用，就是类型为 TYPE_APPLICATION 的 Window。最近一些工具应用开始使用悬浮窗，特别是一些手机清理软件，悬浮窗通常采用的是 TYPE_SYSTEM_ALERT、TYPE_PHONE, 对于 API 在 19 以上的系统，使用的是 TYPE_TOAST。</p><p>成功的男人背后都有一个伟大的女人，一个成功的 Window 背后就有一个伟大的 WindowMananger。WindowManager 本身是一个接口，提供了与 Window 交互的基础功能，分别是添加、更新和删除 View 的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowManager 的实现沿用了 C/S 结构，WindowManager 只作为一个代理，实际工作的是 WindowManagerService。WindowManangerService 以 Session 的形式来管理各个 Application 的窗口，系统启动了多少个含有 View 的应用，就有多少个对应的 Session。</p><p>一个好汉三个帮，View 系统也不例外，WindowManager 与 View 之间不直接进行交互，而是依托于一个中间商，叫做 ViewRoot。ViewRoot 本身是一个 Handler，通过 ViewRoot 实现了两者间的消息传递。ViewRoot 将通知 View 进行相应的界面绘制，然后调用 WindowManager 提供的接口，将 View 添加或更新到 Window 上面。</p><hr><h2 id="添加-DecorView-到-PhoneWindow"><a href="#添加-DecorView-到-PhoneWindow" class="headerlink" title="添加 DecorView 到 PhoneWindow"></a>添加 DecorView 到 PhoneWindow</h2><p>我们以 Activity 的 setContentView 入手，看看窗口管理系统是如何介入这个过程的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 getWindow 方法，需要解释的是对于每个 Activity 而言都有一个对应的窗口，就是前文提及的 PhoneWindow，这个 PhoneWindow 有一个 View ，叫做 DecorView，这也是界面布局的根节点。随便找了一个 App 的界面，大家可以注意箭头标示的地方，那里就是 DecorView。</p><p>setContentView 的实现在其子类 PhoneWindow 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在于 installDecor 方法中，这里是给 Window 添加根 View，也就是 DecorView。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中完成了 Transaction 动画的设置，标题栏的配置，decor 背景的设置等等初始化工作。代码相对比较繁琐，有兴趣的同学，可以看看源码中 PhoneWindow 的实现。</p><p>在这之后，View 就可以显示了吗？大家可能也不会觉得是这么简单的，毕竟我们熟知的 onMeasure、onLayout 和 onDraw 都还没有调用呢？看起来，我们需要一个时机来触发 View 的操作。在下一小节，就来说一下什么时候触发这一过程。</p><hr><h2 id="View-什么时候开始绘制"><a href="#View-什么时候开始绘制" class="headerlink" title="View 什么时候开始绘制"></a>View 什么时候开始绘制</h2><p>Android 系统在 4.0 后为更好的用户体验，执行了一个「黄油计划」，而其中最重要的部分就是垂直同步机制(VSYNC)。让我们首先在大体上理解一下 VSYNC。</p><blockquote><p>VSync stands for Vertical Synchronization. The basic idea is that synchronizes your FPS with your monitor’s refresh rate. The purpose is to eliminate something called “tearing”. I will describe all these things here. Every CRT monitor has a refresh rate.</p></blockquote><p>这是从一篇论文里面引用过来的，VSYNC 就是一种同步机制，以某种固定的频率进行同步，当其他组件收到这个同步信号时，就执行相应的操作。设想一下，如果没有这个同步机制，各个模块又怎能知道在哪个时候去执行自己的工作了？ 这里可以初步地将 VSYNC 当做闹钟，每间隔固定时间，就响一次，其他组件听到闹铃后，就开始干活了。这个间隔的时间，与屏幕刷新频率有关，例如大多数 Android 设备的刷新频率是 60 FPS(Frame per second)，一秒钟刷新60次，因而间隔时间就是 1000 / 60 = 16.667 ms。这个时间，大家是不是很熟悉了？看过太多性能优化的文章，都说每一帧的绘制时间不要超过 16 ms，其背后的原因就是这个。绘制每一帧对应的 View，这个步骤发生在 UI 线程上，所以也不要在 UI 线程上进行耗时的操作，否则就可能在 16 ms内，无法完成界面更新操作了。</p><p><img src="/images/blog/vsync.png" alt="VSYNC"></p><p>为了将 VSYNC 机制在 Framework 落地下来，在 View 层引入了 <a href="https://developer.android.com/reference/android/view/Choreographer.html" target="_blank" rel="noopener">Choreographer</a>。这个类的主要责任就是协调动画、输入和绘制，使得用户体验上达到一致的效果。通常情况下，我们不用去理会这个 Choreographer，Android Framework 通过更高层级的抽象，帮我们完成了这一步骤，他们分别实现在 Animation，onDraw 等代码中。</p><p>下面大体上，看看 Choreographer 的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里采用了 ThreadLocal 这个关键字，使用这个关键字后，能够保证对于单个线程，只能获取到同一实例。而 Choreographer 在构建的时候，还要求这个线程必须有 Looper，Choreographer 需要利用 Looper 来进行相应的消息通知。再看看构造函数的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建了一个 Handler 用来做消息通信，其后建立了一个 CallbackQueue，这里的 CallbackQueue 主要有四种形式，当收到 VSYNC 信号后，依次执行其中的 Callback。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line"></span><br><span class="line">    mFrameInfo.markInputHandlingStart();</span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">    mFrameInfo.markAnimationsStart();</span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">    mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">    doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 CALLBACK_TRAVERSAL 就是与 View 绘制相关的部分。在 ViewRootImpl 代码中，也可以证实到这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 mTraversalRunnable 实现非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而从 doTraversal 开始，View 就开始真正进行绘制了。在 Choreographer 的英明领导下，View 开始准备开工干活了。</p><p>这里和前面的知识进行下串联，再进行下总结。</p><blockquote><p>当 Choreographer 接收到 VSYNC 信号后，ViewRootImpl 调用 scheduleTraversals 方法，通知 View 进行相应的渲染，其后 ViewRootImpl 将 View 添加或更新到 Window 上去。</p></blockquote><p>在 doTraversal 方法中，会调用到 performTraversals 方法，这是一个巨长的方法，在 API-23 版本中，代码行数达到了800行。我们绝大多数的类，都没有达到这个数量级 ：）。在这个方法里，就会执行到我们熟悉的 View 三部曲，Measure、Layout 和 Draw。</p><p>在后续的文章中，再来详细说明 View 中的 Measure、Layout 和 Draw 是如何实现的。再会 ：）</p><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年10月10日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      android view 的窗口管理系统
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="view" scheme="http://www.woaitqs.cc/tags/view/"/>
    
      <category term="window" scheme="http://www.woaitqs.cc/tags/window/"/>
    
      <category term="窗口管理" scheme="http://www.woaitqs.cc/tags/%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>如何在Activity未注册的情况下启动它</title>
    <link href="http://www.woaitqs.cc/2016/08/17/2016-08-17-launch-activity-without-registering-in-manifest/"/>
    <id>http://www.woaitqs.cc/2016/08/17/2016-08-17-launch-activity-without-registering-in-manifest/</id>
    <published>2016-08-17T08:52:50.000Z</published>
    <updated>2019-07-26T16:06:59.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有时候稍不注意, 忘记在 Manifest 文件中注册 Activity，在运行的时候启动 Activity 时就会触发 <code>ActivityNotFoundException</code> 的异常。对于每一个运行的 Activity 都需要进行注册，这个常识我们都很清楚，但是在插件中这样的要求就有些难以实现，由于宿主程序在设计的时候，不知道插件的细节，更不用说在宿主程序的 Manifest 里面提前注册插件 Activity。</p><p>在这篇文章中，介绍了几种可以绕过 Android 对 Activity 需要注册的限制的实现方式。对这些实现方式的了解，有助于理解 Activity 背后的原理，加深对 ActivityManagerService 等等重要系统服务的认知，是不错的进阶知识。</p><p>在正式开始写之前，我还是想额外地扯扯淡。就我自身看来，插件化技术本身的未来是不明朗的，在后续日趋稳定的类 Reactive Native 技术稳定（国内有 Weex）后，可以帮助我们屏蔽不同版本的兼容性问题，实现动态功能的成本也更低，可能更适合于长远方向。但我依旧还在学习插件化技术，是在于插件化技术的深入理解需要依托于对 Android Framework 层的透彻了解上，通过对此的学习，对自身内功的修炼很有裨益。Android 技术也日新月异的发展，而背后的 Framework 层则相对稳定，设计理念也是大体相同，对于 Framework 层的理解能帮我们构建出更好的程序。这就是你所不能被其他人替代的地方，因为你的不可替代性，也能赢得更好的机会。</p><hr><h2 id="利用接口伪装"><a href="#利用接口伪装" class="headerlink" title="利用接口伪装"></a>利用接口伪装</h2><p><a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">dynamic-load-apk</a> 作为第一个将 Android 插件化开源方案出去的项目，提供了最初的解决方案，</p><h3 id="Manifest-注入代理-ProxyActivity"><a href="#Manifest-注入代理-ProxyActivity" class="headerlink" title="Manifest 注入代理 ProxyActivity"></a>Manifest 注入代理 ProxyActivity</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.ryg.dynamicload.DLProxyActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.ryg.dynamicload.proxy.activity.VIEW"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>既然不能提前在 Manifest 里面注册相应的 Activity ，那么就提前注册代理 ProxyActivity，这个代理 Activity 在启动后，会通过静态代理的方式，再实际调用真实 Activity 的方法。</p><p>这里一定要在宿主程序中，声明 DLProxyActivity，目前还没有什么方案可以绕过不需要声明的限制。</p><h3 id="启动插件-Activity"><a href="#启动插件-Activity" class="headerlink" title="启动插件 Activity"></a>启动插件 Activity</h3><p>通常启动 Activity 的时候，代码是这样实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(context, TargetActivity.class);</span><br><span class="line">context.startActivity(intent);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">dynamic-load-apk</a> 在实现的时候为了实现自己代理的效果，进行了自己的封装，将 Intent 封装成 DLIntent。如下面的代码所示，DLIntent 将插件包名和对应插件的 Activity 类传递进来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DLIntent</span><span class="params">(String pluginPackage, String pluginClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.mPluginPackage = pluginPackage;</span><br><span class="line">    <span class="keyword">this</span>.mPluginClass = pluginClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DLIntent</span><span class="params">(String pluginPackage, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.mPluginPackage = pluginPackage;</span><br><span class="line">    <span class="keyword">this</span>.mPluginClass = clazz.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">dynamic-load-apk</a> 如何实现启动 startActivity 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startPluginActivityForResult</span><span class="params">(Context context, DLIntent dlIntent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String packageName = dlIntent.getPluginPackage();</span><br><span class="line">    <span class="comment">//验证intent的包名</span></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"disallow null packageName."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测插件是否加载</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_PKG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要调用的插件Activity的class完整路径</span></span><br><span class="line">    <span class="keyword">final</span> String className = getPluginActivityFullPath(dlIntent, pluginPackage);</span><br><span class="line">    <span class="comment">//Class.forName</span></span><br><span class="line">    Class&lt;?&gt; clazz = loadPluginClass(pluginPackage.classLoader, className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_CLASS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取代理Activity的class，DLProxyActivity/DLProxyFragmentActivity</span></span><br><span class="line">    Class&lt;? extends Activity&gt; proxyActivityClass = getProxyActivityClass(clazz);</span><br><span class="line">    <span class="keyword">if</span> (proxyActivityClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//put extra data</span></span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_CLASS, className);</span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_PACKAGE, packageName);</span><br><span class="line">    dlIntent.setClass(mContext, proxyActivityClass);</span><br><span class="line">    <span class="comment">//通过context启动宿主Activity</span></span><br><span class="line">    performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">    <span class="keyword">return</span> START_RESULT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 ClassLoader 的方式(这里有具体介绍 <a href="http://www.woaitqs.cc/android/2016/07/26/android-plugin-dynamic-load-classes.html">Android ClassLoader 加载机制</a>) 加载插件。同样在 DLIntent 里面将实际的插件包名和插件对象传递进去，以便后续代理 Activity 调用。注意这里的 <code>getProxyActivityClass</code> 方法返回的是 <code>DLProxyActivity</code>, 也就是说将要启动的 Activity 替换为了代理 Activity。</p><h3 id="处理插件生命周期"><a href="#处理插件生命周期" class="headerlink" title="处理插件生命周期"></a>处理插件生命周期</h3><p>当 ProxyActivity 启动后，在相应的生命周期时通过反射的方式调用实际 Activity 中生命周期的方法，但反射这种方式存在两个方法的问题，一是频繁地调用反射会有不可忽视的性能开销，另一方面反射的使用会使得代码难以维护，而且可能存在兼容性问题。就先定义了如下的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DLPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Activity proxyActivity, DLPluginPackage pluginPackage)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowAttributesChanged</span><span class="params">(LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWindowFocusChanged</span><span class="params">(<span class="keyword">boolean</span> hasFocus)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理 Activity 实现了这个接口，并在相应的接口中，去调用插件 Activity 的方法，从而实现偷天换日的功效。下面以 <code>finish</code> 函数为例，说明如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLBasePluginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Activity proxyActivity, DLPluginPackage pluginPackage)</span> </span>&#123;</span><br><span class="line">      mProxyActivity = (Activity) proxyActivity;</span><br><span class="line">      that = mProxyActivity;</span><br><span class="line">      mPluginPackage = pluginPackage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">          <span class="keyword">super</span>.finish();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mProxyActivity.finish();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案只差最后，怎么将 TargetActivity 和 ProxyActivity 绑定在一起了? dynamic-load-apk 中 launchTargetActivity 实现了这个功能，在其中的 attach 函数里面，将 ProxyActivity 和 PluginActivity 绑定在一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launchTargetActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; localClass = getClassLoader().loadClass(mClass);</span><br><span class="line">        Constructor&lt;?&gt; localConstructor = localClass.getConstructor(<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">        Object instance = localConstructor.newInstance(<span class="keyword">new</span> Object[] &#123;&#125;);</span><br><span class="line">        mPluginActivity = (DLPlugin) instance;</span><br><span class="line">        ((DLAttachable) mProxyActivity).attach(mPluginActivity, mPluginManager);</span><br><span class="line">        <span class="comment">// attach the proxy activity and plugin package to the mPluginActivity</span></span><br><span class="line">        mPluginActivity.attach(mProxyActivity, mPluginPackage);</span><br><span class="line"></span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putInt(DLConstants.FROM, DLConstants.FROM_EXTERNAL);</span><br><span class="line">        mPluginActivity.onCreate(bundle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上诉的步骤，就可以绕过 Activity 需要注册的限制了，但这个方案也有一定的限制。不仅要求，插件和宿主都必须同时依赖于一个接口工程，这样会严重制约插件的实现。另一方面，对于 Activity 可以这么实现，但是对于 Service 等等其他组件，也需要进行同样的接口代理，在代码的可读性上不是很好。于是，插件化在发展一段时间后，有了如下的解决方案。</p><hr><h2 id="构建-APP-虚拟运行环境"><a href="#构建-APP-虚拟运行环境" class="headerlink" title="构建 APP 虚拟运行环境"></a>构建 APP 虚拟运行环境</h2><p>构建虚拟运行环境的方式，提供了一种一劳永逸的方案，这种方案通过反射、动态代理等技术，将 APP 需要运行的系统服务进行了特殊处理，欺上瞒下，使得 APP 能在不安装的情况下，运行起来。在这种情况下，自然而然就没有前面方案中，需要额外依赖工程的弊端，也不需要插件为了继承做什么特殊处理。而实现这种虚拟运行环境，需要大量的工程，对每个系统服务都进行特殊处理，在这里就不展开叙述了，只说明 Activity 如何在这个虚拟环境下跑起来。</p><h3 id="拦截-startActivity-请求"><a href="#拦截-startActivity-请求" class="headerlink" title="拦截 startActivity 请求"></a>拦截 startActivity 请求</h3><p>为了不让插件做额外的工作，我们必须对拦截 startActivity, 进行偷天换日的工作。这里用到的技术就是动态代理，关于动态代理如何实现，网上有不少的文章可以参考，不再详述。 startActivty 众多签名的方法中，最后都会进入到 ActivityManager 中去，因而对 ActivityManager 进行代理是不错的选择，而实际上 ActivityManager 所做的工作是通过 Binder 机制对 ActivityManagerService 的调用。最后的代理工作，还是要回到 ActivityManagerService 里面来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ActivityManagerNative.gDefault.type() == IActivityManager.class) &#123;</span><br><span class="line">  ActivityManagerNative.gDefault.set(getHookObject().getProxyObject());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActivityManagerNative.gDefault.type() == android.util.Singleton.class) &#123;</span><br><span class="line">  Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">  Singleton.mInstance.set(gDefault, getHookObject().getProxyObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，ActivtyManagerNative 是 ActivityManagerService 的基类，对 ActivityManagerNative 的修改作用于 ActivityManagerService。这里针对了不同 SDK 版本做了不同的处理，总之在这个替换后，ActivityManagerService 中的 gDefault 变量已经变成我们 hook 后的对象了，<code>getHookObject().getProxyObject()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HookBinder&lt;IActivityManager&gt; hookAMBinder = <span class="keyword">new</span> HookBinder&lt;IActivityManager&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> IBinder <span class="title">queryBaseBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">createInterface</span><span class="params">(IBinder baseBinder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHookObject().getProxyObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">hookAMBinder.injectService(Context.ACTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectService</span><span class="params">(String name)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  Map&lt;String, IBinder&gt; sCache = mirror.android.os.ServiceManager.sCache.get();</span><br><span class="line">  <span class="keyword">if</span> (sCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sCache.remove(name);</span><br><span class="line">    sCache.put(name, <span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ServiceManager is invisible."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接下来的这段代码里面，是替换 SystemServer 中存放的 ActivityManagerService 变量，这样在上面两个地方进行代理之后，已经将所有和 ActivityManagerService (以下简称 AMS) 相关的入口都进行了处理，这样当我们调用 startActivity 方法时，就能进入到我们代理的对象中。接下来看看，这个代理对象应该如何实现。</p><p>代理所完成的工作是对 AMS 进行各种改动，已达成完成启动插件 Activity 的目的，这里就只从 startActivity 这个方法入手，其他方法可以逐类旁通。</p><p>我们先看看 startActivity 的方法签名，这个函数在不同版本的签名也各不相同，下面演示的是基于 SDK-23 源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol><li><p>其中 intent 参数就是我们传入的启动 Intent；</p></li><li><p>caller 是传入到 AMS 中的 binder, 当通知 Activity 启动或者其他事件完成的时候，就可以通过这个 Binder 对象进行通知 Activty 进行生命周期处理了；</p></li><li><p>resultTo 这个参数是 ActivtyRecord 中的变量，这里用来表征一个 Activity。 resultTo 本事是 Binder 对象，而 Binder 对象可以在跨进程中起到唯一标示的作用。</p></li></ol><p>其余参数就不再叙述了，现在看看 startActivity 具体是怎么拦截的。Java 一般使用 InvocationHandler 来进行动态代理，代理过后会调用到 <code>invoke</code>方法 , 当 method.getName 是 startActivity 时，我们就可以进行拦截了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取必要的参数，并保存下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> intentIndex = ArrayUtils.indexOfFirst(args, Intent.class);</span><br><span class="line"><span class="keyword">int</span> resultToIndex = ArrayUtils.indexOfObject(args, IBinder.class, <span class="number">2</span>);</span><br><span class="line">String resolvedType = (String) args[intentIndex + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">Intent targetIntent = (Intent) args[intentIndex];</span><br><span class="line">targetIntent.setDataAndType(targetIntent.getData(), resolvedType);</span><br><span class="line">IBinder resultTo = resultToIndex != -<span class="number">1</span> ? (IBinder) args[resultToIndex] : <span class="keyword">null</span>;</span><br><span class="line">String resultWho = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> requestCode = <span class="number">0</span>;</span><br><span class="line">Bundle options = ArrayUtils.getFirst(args, Bundle.class);</span><br><span class="line"><span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">  resultWho = (String) args[resultToIndex + <span class="number">1</span>];</span><br><span class="line">  requestCode = (<span class="keyword">int</span>) args[resultToIndex + <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> userId = getUserId(targetIntent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</span><br><span class="line">  args[intentIndex - <span class="number">1</span>] = getHostPkg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析-startActivity-中的-Intent"><a href="#解析-startActivity-中的-Intent" class="headerlink" title="解析 startActivity 中的 Intent"></a>解析 startActivity 中的 Intent</h3><p>在上一篇文章中，讲解到如何不经过安装过程，解析 APK 的信息。在得到这些信息之后，VirtualApp(以下简称VA) 会将这些信息组织起来，存放在本地的包服务中。信息的组织形式，与系统的 PackageManagerService 类似，将各大组件、权限等信息保留下来，当调用到 startActivity 时，解析其中的 Intent，查看是否有相应的组件匹配对应的 Intent。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ActivityInfo targetActInfo = VirtualCore.getCore().resolveActivityInfo(targetIntent, userId);</span><br><span class="line"><span class="keyword">if</span> (targetActInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(who, args);</span><br><span class="line">&#125;</span><br><span class="line">String packageName = targetActInfo.packageName;</span><br><span class="line"><span class="keyword">if</span> (!isAppPkg(packageName)) &#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(who, args);</span><br><span class="line">&#125;</span><br><span class="line">Intent resultIntent = VActivityManager.get().startActivity(targetIntent, targetActInfo, resultTo, options, userId);</span><br><span class="line"><span class="keyword">if</span> (resultIntent == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    VActivityManager.get().sendActivityResult(resultTo, resultWho, requestCode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中获取到 intent 对应的 targetActInfo, 如果为空，或者没有在 VirtualApp 里面，就直接调用原有 API 的方法，否则则进入我们的拦截逻辑，看起来 <code>VActivityManager.get().startActivity</code> 是重中之重。</p><h3 id="创建应用进程"><a href="#创建应用进程" class="headerlink" title="创建应用进程"></a>创建应用进程</h3><p>在我之前的一篇文章里，<a href="http://www.woaitqs.cc/android/2016/06/21/activity-service.html">Android 应用进程启动流程</a>, Android 组件的运行都是需要相应的进程的。我们在讲如何启动插件 Activity 的时候，也要处理好这个问题。单独的进程有助于进行数据隔离，当发生意外情况时，不至于影响主进程。皮之不存，毛将焉附，现在看看创建进程，让插件 Activity 可以依附。</p><p>VirtualApp 会预先在 AndroidManifest 通过 <code>android:process</code> 来预置一些进程，当有需要的时候，会查看这些进程是否存在，利用其未占用的进程给插件使用。下面截取了一段 AndroidManifest 中的代码，可以注意其中的 <code>android:process</code> 字段。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.lody.virtual.client.stub.StubActivity$C0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"mcc|mnc|locale|...|fontScale"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":p0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.lody.virtual.vt"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/VATheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"X-Identity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">"Stub-User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"com.lody.virtual.client.stub.StubActivity$C1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"mcc|mnc|locale|...|fontScale"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":p1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">"com.lody.virtual.vt"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/VATheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"X-Identity"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">"Stub-User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>VActivityManagerService(以下简称VAMS) 在启动后，会遍历对应 Manifest 文件中的 Activity 和 Provider 组件，并查看其中的 processName，通过 Map 建立起 processName 和对应 Activity 和 Provider 之间的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">PackageInfo packageInfo = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  packageInfo = pm.getPackageInfo(context.getPackageName(),</span><br><span class="line">      PackageManager.GET_ACTIVITIES | PackageManager.GET_PROVIDERS</span><br><span class="line">      | PackageManager.GET_META_DATA);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ActivityInfo[] activityInfos = packageInfo.activities;</span><br><span class="line"><span class="keyword">for</span> (ActivityInfo activityInfo : activityInfos) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isStubComponent(activityInfo)) &#123;</span><br><span class="line">    String processName = activityInfo.processName;</span><br><span class="line">    stubProcessList.add(processName);</span><br><span class="line">    StubInfo stubInfo = stubInfoMap.get(processName);</span><br><span class="line">    <span class="keyword">if</span> (stubInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">      stubInfo = <span class="keyword">new</span> StubInfo();</span><br><span class="line">      stubInfo.processName = processName;</span><br><span class="line">      stubInfoMap.put(processName, stubInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    String name = activityInfo.name;</span><br><span class="line">    <span class="keyword">if</span> (name.endsWith(<span class="string">"_"</span>)) &#123;</span><br><span class="line">      stubInfo.dialogActivityInfos.add(activityInfo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stubInfo.standardActivityInfos.add(activityInfo);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要启动进程时，就从 stubInfoMap 里面去查看是否有空闲的进程可供使用。如果存在空闲的进程，则通过前面提到的 Map，从进程名得到相应的 Stub 信息。进程的创建是相对重量级的事情，而 VA 只用了几行代码，就完成了这个事情，利用的正是 Android Provider 的机制。当 Provider 启动的时候，可以同步地启动对应的进程，具体原理可以参看 <a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="noopener">这篇文章</a>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bundle <span class="title">call</span><span class="params">(String authority, Context context, String methodName, String arg, Bundle bundle)</span> </span>&#123;</span><br><span class="line">  Uri uri = Uri.parse(<span class="string">"content://"</span> + authority);</span><br><span class="line">  ContentResolver contentResolver = context.getContentResolver();</span><br><span class="line">  <span class="keyword">return</span> contentResolver.call(uri, methodName, arg, bundle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程启动后，还需要将这个进程和插件具体绑定起来，使得这个进程能够当做 Application 来运行，这段逻辑也相对复杂，有兴趣的可以看看 <code>VClientImpl</code> 的实现。</p><h3 id="斗转星移绕过-Manifest-的限制"><a href="#斗转星移绕过-Manifest-的限制" class="headerlink" title="斗转星移绕过 Manifest 的限制"></a>斗转星移绕过 Manifest 的限制</h3><p>在进程创建成功后，<code>startProcessIfNeedLocked</code> 可以得到对应的 ProcessRecord 对象，这个对象中存放着相应的 Activity、Service 等等组件信息，当然也包括用于偷换概念的 Stub 信息。在进程启动后，将对应的 Stub 放置在 intent 中，并通过 Binder 机制返回给 Client 端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ProcessRecord processRecord = mService.startProcessIfNeedLocked(info.processName, userId, info.packageName);</span><br><span class="line"><span class="keyword">if</span> (processRecord == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">StubInfo selectedStub = processRecord.stubInfo;</span><br><span class="line">ActivityInfo stubActInfo = selectedStub.fetchStubActivityInfo(info);</span><br><span class="line"><span class="keyword">if</span> (stubActInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">newIntent.setClassName(stubActInfo.packageName, stubActInfo.name);</span><br><span class="line">newIntent.putExtra(<span class="string">"_VA_|_intent_"</span>, intent);</span><br><span class="line">newIntent.putExtra(<span class="string">"_VA_|_stub_activity_"</span>, stubActInfo);</span><br><span class="line">newIntent.putExtra(<span class="string">"_VA_|_target_activity_"</span>, info);</span><br><span class="line">newIntent.putExtra(<span class="string">"_VA_|_user_id_"</span>, userId);</span><br><span class="line"><span class="keyword">return</span> newIntent;</span><br></pre></td></tr></table></figure><p>重点来啦，在上面的 newIntent 中，将 className 设置成为代理 Activity 的信息。在 Client 端，获取到这个 resultIntent 后，将这个值注入到 startActivity 的 intent 里面去，在 args[intentIndex] = resultIntent 这里进行的替换。而在这里进行替换过后，就可以绕过 AMS 的对 Activity 需要注册的限制了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">onHook</span><span class="params">(Object who, Method method, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onHook(who, method, args);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Intent resultIntent =</span><br><span class="line">    VActivityManager.get().startActivity(</span><br><span class="line">      targetIntent, targetActInfo, resultTo, options, userId);</span><br><span class="line">  <span class="keyword">if</span> (resultIntent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">      VActivityManager.get().sendActivityResult(resultTo, resultWho, requestCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  args[intentIndex] = resultIntent;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(who, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="给插件-Activity-注入生命"><a href="#给插件-Activity-注入生命" class="headerlink" title="给插件 Activity 注入生命"></a>给插件 Activity 注入生命</h3><p>上段代码中的 <code>method.invoke(who, args)</code>, 执行的是 SDK 中 startActivity 的逻辑。这个逻辑里面执行的是启动逻辑，在这里篇幅的限制，就不再详细说明了，大家可以看我的这篇博文，<a href="http://www.woaitqs.cc/android/2016/07/19/how-activity-lifecircle-work">Android Activity 生命周期是如何实现的</a>, 最终程序会执行到 ActivityThread.mH 中去，对应的消息就是 <code>LAUNCH_ACTIVITY</code>，其后执行的方法就是下面代码所描述的这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleLaunchActivity</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  Object r = msg.obj;</span><br><span class="line">  <span class="comment">// StubIntent</span></span><br><span class="line">  Intent stubIntent = ActivityThread.ActivityClientRecord.intent.get(r);</span><br><span class="line">  <span class="comment">// TargetIntent</span></span><br><span class="line">  Intent targetIntent = stubIntent.getParcelableExtra(<span class="string">"_VA_|_intent_"</span>);</span><br><span class="line"></span><br><span class="line">  ComponentName component = targetIntent.getComponent();</span><br><span class="line">  String packageName = component.getPackageName();</span><br><span class="line"></span><br><span class="line">  AppSetting appSetting = VirtualCore.getCore().findApp(packageName);</span><br><span class="line">  <span class="keyword">if</span> (appSetting == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从 Intent 中获取的 stub 和 target 的信息</span></span><br><span class="line">  ActivityInfo stubActInfo = stubIntent.getParcelableExtra(<span class="string">"_VA_|_stub_activity_"</span>);</span><br><span class="line">  ActivityInfo targetActInfo = stubIntent.getParcelableExtra(<span class="string">"_VA_|_target_activity_"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stubActInfo == <span class="keyword">null</span> || targetActInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String processName = ComponentUtils.getProcessName(targetActInfo);</span><br><span class="line">  <span class="comment">// 保证 Process 已经与 Application 绑定起来</span></span><br><span class="line">  <span class="keyword">if</span> (!VClientImpl.getClient().isBound()) &#123;</span><br><span class="line">    <span class="keyword">int</span> targetUser = stubIntent.getIntExtra(<span class="string">"_VA_|_user_id_"</span>, <span class="number">0</span>);</span><br><span class="line">    VActivityManager.get().ensureAppBound(processName, appSetting.packageName, targetUser);</span><br><span class="line">    getH().sendMessageDelayed(Message.obtain(msg), <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置对应的 classLoader</span></span><br><span class="line">  ClassLoader appClassLoader = VClientImpl.getClient().getClassLoader(targetActInfo.applicationInfo);</span><br><span class="line">  targetIntent.setExtrasClassLoader(appClassLoader);</span><br><span class="line">  <span class="keyword">boolean</span> error = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    targetIntent.putExtra(<span class="string">"_VA_|_stub_activity_"</span>, stubActInfo);</span><br><span class="line">    targetIntent.putExtra(<span class="string">"_VA_|_target_activity_"</span>, targetActInfo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    error = <span class="keyword">true</span>;</span><br><span class="line">    VLog.w(TAG, <span class="string">"Directly putExtra failed: %s."</span>, e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error &amp;&amp; Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    ClassLoader oldParent = getClass().getClassLoader().getParent();</span><br><span class="line">    mirror.java.lang.ClassLoader.parent.set(getClass().getClassLoader(), appClassLoader);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      targetIntent.putExtra(<span class="string">"_VA_|_stub_activity_"</span>, stubActInfo);</span><br><span class="line">      targetIntent.putExtra(<span class="string">"_VA_|_target_activity_"</span>, targetActInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      VLog.w(TAG, <span class="string">"Secondly putExtra failed: %s."</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    mirror.java.lang.ClassLoader.parent.set(getClass().getClassLoader(), oldParent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反射替换其中的 intent 和 activityInfo, 将 Stub 相关的信息换成 target 相关的信息</span></span><br><span class="line">  ActivityThread.ActivityClientRecord.intent.set(r, targetIntent);</span><br><span class="line">  ActivityThread.ActivityClientRecord.activityInfo.set(r, targetActInfo);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是重点，这里将 ActivityClientRecord 中的相应信息替换为了插件 Activity，从这一步过后，对应的插件 Activity 就能通过这个 H Callback 接收到相应的生命周期回调，从这一刻开始，插件 Activity 就是有血有肉的存在了。</p><h3 id="总结-VA-的实现方式"><a href="#总结-VA-的实现方式" class="headerlink" title="总结 VA 的实现方式"></a>总结 VA 的实现方式</h3><p>可能大家在看前面的描述过后，如果对 AMS 这一块比较熟悉的话，就会发现所做的工作其实特别简单。第一步，就是将 startActivity 中的 intent 参数，替换为插件 Activity 的信息；第二步，是在欺骗完系统后，在 H Callback 的 <code>LAUNCH_ACTIVITY</code> 消息中，将对应 Record 中的信息，还原为插件的 Activity 信息。</p><p>读者也许会问，难道真的就这么简单，就可以欺骗系统了吗？我们先通过 <code>adb shell dumpsys activity</code> 的方式，看看在 AMS 这个视角上，运行的是哪个 Activity？</p><p><del>此处应该有图，但是万恶的七牛需要备案的域名才能使用，而我未对图片进行备份。</del></p><p>看来，AMS 还真天真地运行着 StubActivity，在前面欺骗的环节中，传递进去的确实是 StubActivity，而为何在实际运行的时候，客户端还能继续使用插件 Activity 了？在<a href="http://www.woaitqs.cc/2016/07/19/how-activity-lifecircle-work">Android Activity 生命周期是如何实现的</a> 这篇文章里面讲到，在 ActivityThread 中的 performLaunchActivity 方法里面，实际去调用 Activity 的 onCreate 方法，而在这个 performLaunchActivity 里面有这样一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">  ActivityInfo aInfo = r.activityInfo;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other code.</span></span><br><span class="line"></span><br><span class="line">  activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                          r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                          r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                          r.referrer, r.voiceInteractor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用方法时，已经在 H Callback 中将 ActivityClientRecord 替换为插件 Activity，而在 attach 的时候，也是将这个 token 作为参数写入进去。因而后续在 Client 段实际使用的是插件 Activity，尽管系统依然用着 StubActivity。</p><p>360 的 DP 方案，采用的也是类似的技术，大家可以最后进行下对比。</p><hr><h3 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h3><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年8月25日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      大话插件 - 动态加载插件 Activity，Android ClassLoader 相关的原理，动态加载 Activity 的技术
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="android" scheme="http://www.woaitqs.cc/tags/android/"/>
    
      <category term="plugin" scheme="http://www.woaitqs.cc/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>和Android Memory谈一场不分手的恋爱</title>
    <link href="http://www.woaitqs.cc/2016/03/30/2016-03-30-in-love-with-android-memory/"/>
    <id>http://www.woaitqs.cc/2016/03/30/2016-03-30-in-love-with-android-memory/</id>
    <published>2016-03-30T08:52:50.000Z</published>
    <updated>2019-07-26T15:02:20.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、待嫁闺中"><a href="#一、待嫁闺中" class="headerlink" title="一、待嫁闺中"></a>一、待嫁闺中</h2><p>爱情大多数时候都是美好而甜蜜的，但也时常让我们烦恼，内存也是这样的，自动垃圾回收使得我们不用管内存的分配和释放，但稍微不注意，可能就掉进坑里面了。这边文章将主要围绕 Android Memory的各个方面进行展开，让我们知道如何与 Memory 谈恋爱，并尽可能地甜蜜。</p><p>内存是一个有着沉鱼落雁面容，和体贴善良的女子，她对你含情脉脉的眼神，让你心动流连(妈蛋又跑题了)。Android会给每个应用程序分配适当大小的线程，这样想象如果不加以限制，势必会影响到其他程序和系统本身的稳定性。内存主要是分为两部分，堆和栈(实际上还有方法区，常量池等)。具体可参看<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解java虚拟机》</a></p><p>栈一般与线程相关，JVM(Davlik/Art)在创建每一个线程的时候，会分配一定的栈空间给线程，栈中存储这基本类型数据，以及对象引用等，这些部分主要用于解决程序的运行问题，这就好比内存妹子的灵魂。</p><p>相对而言，堆则用来解决程序的数据存储问题，这就是内存的肉身。如果想要知道妹子有多重，告诉你一个秘诀, 通过<code>getMemoryClass</code>方法可以得知。堆是程序主要进行分配和释放的地方，因而这一块需要良好的管理。下面介绍Android如何进行垃圾回收。</p><hr><h2 id="二、举案齐眉"><a href="#二、举案齐眉" class="headerlink" title="二、举案齐眉"></a>二、举案齐眉</h2><p>爱情是一门付出与回报的行为艺术，两者总是相辅相成的。而Android内存模型，通过自动垃圾回收的方式，帮我们完成了这一过程。我们使用Android内存模块来获取内存，然后内存回收模块回收掉不再使用的内存。</p><h3 id="堆的分区"><a href="#堆的分区" class="headerlink" title="堆的分区"></a>堆的分区</h3><p>年轻代：新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说发生了一次“minor GC”。<br>年老代：经过几次收集，寿命不断延长，一段时间后依然存活的对象。<br>永久代：主要存放加载的Class类级对象如class本身，method，field。</p><h3 id="如何知道对象不再使用？"><a href="#如何知道对象不再使用？" class="headerlink" title="如何知道对象不再使用？"></a>如何知道对象不再使用？</h3><p>早期的垃圾回收采用引用计数(reference counting)的机制。每个对象包含一个计数器。当有新的指向该对象的引用时，计数器加1。当引用移除时，计数器减1。当计数器为0时，认为该对象可以进行垃圾回收。但这样存在的问题，在于循环引用上面，如果A引用B，B引用A，即便两者都不再使用，也无法释放内存。</p><p>为了解决对象循环引用这个问题，后续采用了更为准确的对象遍历方式。如下图所示，垃圾回收器会建立有向图的方式进行内存管理，通过GC Roots来往下遍历，当发现有对象出于不可达状态的时候，就会对其标记为不可达，以便于后续的GC回收。</p><p><img src="/images/blog/gc-root.jpg" alt="GC遍历"></p><h3 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h3><ol><li>调用函数dvmHeapSourceAlloc在Java堆上分配指定大小的内存。如果分配成功，那么就将分配得到的地址直接返回给调用者了。函数dvmHeapSourceAlloc在不改变Java堆当前大小的前提下进行内存分配，这是属于轻量级的内存分配动作。</li><li>如果上一步内存分配失败，这时候就需要执行一次GC了。不过如果GC线程已经在运行中，即gDvm.gcHeap-&gt;gcRunning的值等于True，那么就直接调用函数dvmWaitForConcurrentGcToComplete等到GC执行完成就是了。否则的话，就需要调用函数gcForMalloc来执行一次GC了，参数False表示不要回收软引用对象引用的对象。</li><li>GC执行完毕后，再次调用函数dvmHeapSourceAlloc尝试轻量级的内存分配操作。如果分配成功，那么就将分配得到的地址直接返回给调用者了。</li><li>如果上一步内存分配失败，这时候就得考虑先将Java堆的当前大小设置为Dalvik虚拟机启动时指定的Java堆最大值，再进行内存分配了。这是通过调用函数dvmHeapSourceAllocAndGrow来实现的。</li><li>如果调用函数dvmHeapSourceAllocAndGrow分配内存成功，则直接将分配得到的地址直接返回给调用者了。</li><li>如果上一步内存分配还是失败，这时候就得出狠招了。再次调用函数gcForMalloc来执行GC。参数true表示要回收软引用对象引用的对象。</li><li>GC执行完毕，再次调用函数dvmHeapSourceAllocAndGrow进行内存分配。这是最后一次努力了，成功与事都到此为止。</li></ol><p>总结的说，GC发生一般发生在两种情况下。第一种情况是没有足够内存分配请求的分存时，会调用Heap类的成员函数CollectGarbageInternal触发一个原因为kGcCauseForAlloc的GC。第二种情况下分配出请求的内存之后，堆剩下的内存超过一定的阀值，就会调用Heap类的成员函数RequestConcurrentGC请求执行一个并行GC</p><hr><h2 id="三、面有难色"><a href="#三、面有难色" class="headerlink" title="三、面有难色"></a>三、面有难色</h2><p>感情总不会是一帆风顺，友谊的小船也常常说翻就翻。这不内存妹子就发起了小脾气，心情有些抖动，这是一种我们称之为「内存抖动」的现象。</p><p>在极短的时间内，分配大量的内存，然后又释放它，这种现象就会造成内存抖动。典型的情况是，在View控件的onDraw方法里分配大量内存，又释放大量内存，这种做法极易引起内存抖动，从而导致性能下降。因为onDraw里的大量内存分配和释放会给系统堆空间造成压力，触发GC工作去释放更多可用内存，而GC工作起来时，又会吃掉宝贵的帧时间 (帧时间是 16ms)，最终导致性能问题。</p><p><img src="http://hukai.me/images/gc_overtime.png" alt="绘制超时"></p><p><img src="https://raw.githubusercontent.com/kamidox/blogs/master/images/memory_churn.gif" alt="内存抖动示例"></p><p style="color:red">这个地方还需要完善</p><hr><h2 id="四、心存芥蒂"><a href="#四、心存芥蒂" class="headerlink" title="四、心存芥蒂"></a>四、心存芥蒂</h2><p>爱情并不是在任何时候都那么美丽，也时常闹矛盾。内存是个敏感的姑娘，你对她不精心的小伤害，也往往让她对你心存芥蒂，久而久之可能最后分崩离析。在进行的开发的过程中，要注意哪些忽略她感受的小细节，这些细节让她对你的安全感下降很多。我们称这种现象为「内存泄露」。</p><p>Android内存泄漏指的是进程中某些对象（垃圾对象）已经没有使用价值了，但是它们却可以直接或间接地引用到 gc roots 导致无法被GC回收。无用的对象占据着内存空间，使得实际可使用内存变小，形象地说法就是内存泄漏了。</p><h3 id="泄漏有哪些危害"><a href="#泄漏有哪些危害" class="headerlink" title="泄漏有哪些危害"></a>泄漏有哪些危害</h3><p>运行性能的问题: Android在运行的时候，如果内存泄露导致其他组件可用的内存变少，一方面会使得GC的频率加剧，在发生GC的时候，所有进程都必须进行等待，GC的频率越多，从而用户越容易感知到卡顿。另一方面，内存变少，将可能使得系统会额外分配给你一些内存，而影响整个系统的运行状况。</p><p>运行崩溃问题: 一旦内存不足以分配某些内存，那么将会导致崩溃，这对于体验而言是致命的。我们在进行内存分析的时候，可以发现总有一些机型会出现OutOfMemory的崩溃栈，大抵都和内存泄露有关。</p><h3 id="泄漏示例"><a href="#泄漏示例" class="headerlink" title="泄漏示例"></a>泄漏示例</h3><p>来看看下面这个例子，DataContainer 负责抓取和更新数据，我们可以通过 <code>register(DataListener listener)</code>方法来对数据更新进行关注。<code>MainActivity</code>就关注了DataListener，因而当数据发生回调的时候，<code>MainActivity</code>就能立刻做出相应。</p><p>其实这里发生了比较严重的泄漏情况，在启动<code>MainActivity</code>的时候，<code>MainActivity</code> 就会将 <code>DataListener</code> 注入到<code>DataContainer</code>里，而在<code>MainActivity</code>退出的时候，即使<code>MainActivity</code>不再使用，但是由于其被<code>DataContainer</code>所引用，导致<code>MainActivity</code>无法被回收，将会一直占据着内存，影响程序的运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;DataListener&gt; dataListeners;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DataContainer instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> DataContainer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DataContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataListeners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataContainer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 监听数据变化.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(DataListener listener)</span> </span>&#123;</span><br><span class="line">    dataListeners.add(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDataChanged</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">DataContainer</span>.<span class="title">DataListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    LeakContainer.getInstance().register(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Toast.show</span><br><span class="line">    <span class="comment">// do nothings.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位泄漏的方法"><a href="#定位泄漏的方法" class="headerlink" title="定位泄漏的方法"></a>定位泄漏的方法</h3><p>女生的小情绪，往往难以琢磨，如果我们忽略这些小脾气，往往又会得到惩罚。因而我们需要寻找一种方法来定位可能的对于内存妹纸的伤害。我们将分别从两个方面，来帮助我们分析和定位。一是宏观方法，通过一些很简单的方法来判断是否存在泄露，另一方面是通过精确定位的方式来提出具体的解决方案。</p><ol><li>Android Studio Memory Monitor</li></ol><p>Android Studio 提供了非常方便的工具，便于我们定位问题。Android Monitors模块中含有 Memory Tab，这个Tab以流线的方式，展示了每一时刻内，已分配的内存和还空闲的内存。</p><p>图中浅蓝颜色的部分表示已经分配的内存，而灰色部分表明空闲的内存。<br><img src="https://ooo.0o0.ooo/2016/04/01/56fe26ccc38ea.png" alt="gettingstarted_image003.png"><br>总选中Devices和相应的包名后，就能看到动态内存分配的情况。<br><img src="https://ooo.0o0.ooo/2016/04/01/56fe26cccacd4.png" alt="gettingstarted_image002.png"><br>如下图所示，当已分配的内存剧烈下降的时候，就标明发生了GC事件，GC发生的时刻和频率是我们关注的重点。<br><img src="https://ooo.0o0.ooo/2016/04/01/56fe26ccd17d5.png" alt="gettingstarted_image005.png"><br>我们回到刚才的那个例子 #泄漏示例# ，下图是点击<code>MainActivity</code>然后按返回键退出，再进入再退出，重复几次后，内存Monitor显示的结果。从这个例子中，我们可以看到，尽管进过了几次 <code>GC</code>,但是内存用量却一直在增大，说明有些对象被某些静态或者其他GC Roots的对象引用着，导致其不能被释放。因而可以说明，其存在比较严重的内存泄漏问题。<br><img src="https://ooo.0o0.ooo/2016/03/31/56fdeba581676.png" alt="内存泄露"></p><ol start="2"><li>Android Devices Monitor</li></ol><p>Android Devices Monitor提供了比较方便辅助的定位方法，在 <code>Heap</code> Tab下面，显示着<code>% Used</code>的使用量，如果这个值在<code>GC</code>后没有明显下降，那么就意味着发生了内存泄漏，具体的操作步骤如下。</p><ol><li>选择DDMS视图，并打开Devices视图和Heap视图</li><li>点击选择要监控的进程，比如：上图中我选择的是system_process</li><li>选中Devices视图界面上的<code>update heap</code>图标</li><li>点击Heap视图中的<code>Cause GC</code> 按钮（相当于向虚拟机发送了一次GC请求的操作）</li></ol><p>第一次点击<code>Cause GC</code>后的内存占比<br><img src="https://ooo.0o0.ooo/2016/04/01/56fe7a65a5289.png" alt="QQ20160401-1.png"><br>在多次退出和进入后的内存占比<br><img src="https://ooo.0o0.ooo/2016/04/01/56fe7a65f0c28.png" alt="QQ20160401-2.png"></p><ol start="3"><li>精确定位方法</li></ol><p>我们在查看是否存在内存泄漏情况的时候，基于的基础单位往往是Activity，因而就可以想到一种思路，即通过在界面回退后，强制进行GC，然后判断是否还存在对该Activity的引用，这样就能得知是否存在泄漏。</p><p><img src="https://ooo.0o0.ooo/2016/02/27/56d15d70346dc.png" alt="使用Monitor进行定位"></p><p><a href="http://www.lightskystreet.com/2015/09/01/mat_usage/" target="_blank" rel="noopener">MAT 使用简介</a></p><p>具体的的实施步骤如下：</p><ol><li><p>客户端中打开相应的Activity，并执行可能触发内存泄漏的操作.</p></li><li><p>退出Activity界面，并点击Initiate GC(左起第二个按钮)</p></li><li><p>点击Dump Java Heap，等待一会后，这个时候可以看到Dump 出来的日志。</p></li><li><p>由于Android Profile文件不被 MAT 支持，因为我们需要执行转换操作。 ./hprof-conv path/file.hprof exitPath/heap-converted.hprof</p></li><li><p>在 MAT 中打开文件，并选择Leak Suspects Report,等待最后的结果。</p></li><li><p><code>Select * From instanceof android.app.Activity</code> 通过Activity的类名来过滤信息，在右键菜单里面，分别点击Merge Paths to Shortest GC Root 和 exclude all phantom/weak/soft etc. references, 排除被弱引用持有的情况。</p></li><li><p>LeakCanary 自动定位</p></li></ol><p>Square 开源了LeakCanary来用作对于内存泄露情况的自动检测。</p><p>LeakCanary实现了引用观察者RefWatcher。RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。通过在Activity重要的生命周期中，在后台线程检查引用是否被清除，如果没有，调用GC。如果在GC后，引用还是未被清除，那么可能发生了内存泄露，这时候把heap内存dump到 APP 对应的文件系统中的 .hprof 文件中。在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA来解析这个文件。得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。</p><p>可以看到，Square在使用LeakCanary并进行相应的修改后，效果还是相当不错的。<br><img src="https://corner.squareup.com/images/leakcanary/oom_rate.png" alt="内存泄漏比例"><br>由于官方开源的LeakCanary只能在Debug版上使用，在Release上通过NullObject方式实现了一个空实现，来避免性能问题。如果想通过小流量的方式来批量地发现用户内存泄露的情况，那么就需要对源码进行整改，刚好我做了这么一件事情，有兴趣的人可以拿去使用。<a href="https://github.com/woaitqs/leakcanary_without_notification" target="_blank" rel="noopener">移除UI展示等逻辑后可在Release上使用的LeakCanary</a>。有了用户相关的数据的泄露栈就能很好地处理各种泄露问题，使得应用良好稳定地运行。</p><h3 id="常见内存泄漏CASE与修复方法"><a href="#常见内存泄漏CASE与修复方法" class="headerlink" title="常见内存泄漏CASE与修复方法"></a>常见内存泄漏CASE与修复方法</h3><h4 id="泄漏CASE"><a href="#泄漏CASE" class="headerlink" title="泄漏CASE"></a>泄漏CASE</h4><ol><li>注册对象未反注册<br>在组件启动后，注册了某个对象的观察者，在组件回收的时候，忘记取消注册了。可以参考这样的例子，Activity声明的时候实现了对于下载进度接口的监听，而这个监听接口在实现的时候使用的是强引用，如果不进行主动反注册，Activity会因为被下载库持有引用，从而导致无法回收。</li><li>长线执行的异步任务<br>组件内部有一个可能长时间执行的任务，通过内部类持有了对组件的引用。想象这样一个场景，界面上的某一个组件需要异步地去请求天气数据，在得到结果后显示在界面上。在网络回调的Callback中，持有了这个组件，从而在网络请求执行过程中，组件是无法进行回收的。</li><li>Android SDK的泄露<br>这类泄露一般不严重，不用特殊处理。比如TextLine.sCached对象会持有一个拥有三个TextLine的对象池，但TextLine的回收方法recycle处理得有bug，在android-5.1.0_r1修复了一部分，修复连接。其他的泄露地方可从这里看出一部分，SDK泄露统计。</li><li>类的静态变量持有大数据对象<br>静态变量长期维持到大数据对象的引用，阻止垃圾回收。</li><li>资源对象未关闭象<br>资源性对象如Cursor、File、Socket，应该在使用后及时关闭。未在finally中关闭，会导致异常情况下资源对象未被释放的隐患。</li><li>Handler 泄漏<br>Handler通过发送Message与主线程交互，Message发出之后是存储在MessageQueue中的，有些Message也不是马上就被处理的。在Message中存在一个target，是Handler的一个引用，如果Message在Queue中存在的时间越长，就会导致Handler无法被回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。handler在使用过后，在组件退出的时候没有处理这些handler。通过Handler post出去一个任务后，没有在最后调用removeCallbacks的接口，清除掉所有跟这个Runnable相关的message。</li></ol><h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h4><ol><li>尽量避免在组件内部使用内部类，内部的一些逻辑类可以使用Static的声明，避免持有对组件的引用。</li><li>如果一定要持有内部类的引用，可以通过WeakReference来进行封装，这样可以缓解掉一些泄漏情况。</li><li>对于Handler使用较多的情况，可以考虑使用WeakHandler</li><li>正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</li><li>在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。</li><li>对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。</li></ol><hr><h2 id="五、如胶似漆"><a href="#五、如胶似漆" class="headerlink" title="五、如胶似漆"></a>五、如胶似漆</h2><p>处理好爱情里面的小摩擦以后，现在我们来把和内存妹纸的恋爱进行到底，如何呵护好来之不易的感情。接下来的章节将围绕内存优化进行展开，这部分内容也对我们的开发很有帮助。</p><h3 id="善用ArrayMap和SparseArray"><a href="#善用ArrayMap和SparseArray" class="headerlink" title="善用ArrayMap和SparseArray"></a>善用ArrayMap和SparseArray</h3><p>HashMap 在我们的程序中经常出现，作为高效率存储和检索的容器被频繁使用。如果了解<a href="http://woaitqs.github.io/program/2015/04/14/read-source-code-about-hashmap" target="_blank" rel="noopener">HashMap 实现原理</a>的话，就知道这是一种空间换时间的实现方式，在客户端开发中由于内存受限，原来以空间换时间的方式也变得不太适合。为了解决HashMap更占内存的弊端，Android提供了内存效率更高的ArrayMap。它内部使用两个数组进行工作，其中一个数组记录key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value值，如下图所示：<br><img src="http://img.ptcms.csdn.net/article/201508/12/55cafcd911daf.jpg" alt="ArrayMap 原理图"></p><p>当你想获取某个value的时候，ArrayMap会计算输入key转换过后的hash值，然后对hash数组使用二分查找法寻找到对应的index，然后我们可以通过这个index在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的key和前面输入的查询key不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该key为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。并且 ArrayMap 会采用动态数组的方式，始终使得内存占用控制在合理的范围内。</p><p>SparseArray 相对于ArrayMap做了进一步的细化，避免了对基础数据的装箱操作。系统提供了SparseBoolMap，SparseIntMap，SparseLongMap，LongSparseMap等容器。这些容器的使用场景也和ArrayMap一致，需要满足数量级在千以内，数据组织形式需要包含Map结构。</p><h3 id="不要滥用Enum"><a href="#不要滥用Enum" class="headerlink" title="不要滥用Enum"></a>不要滥用Enum</h3><p>在Android最开始的文档中，写着尽量避免使用Enum，认为使用 Enum 带来了不少的性能问题。不过Enum 相对于 int 而言，确实提供了不少的代码可读性，而且在后续的优化中Enum带来的影响也降低了不少。比如当我们发现有人在使用Enum.oridinal()这样的方法时，大概就可以说明Enum被滥用了。</p><p>Android Support提供了更好的方式，在语义限制和性能之间达到一个平衡，这就是<a href="http://developer.android.com/reference/android/support/annotation/StringDef.html" target="_blank" rel="noopener">Android Animation</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(SOURCE)</span><br><span class="line">  <span class="meta">@StringDef</span>(&#123;</span><br><span class="line">     POWER_SERVICE,</span><br><span class="line">     WINDOW_SERVICE,</span><br><span class="line">     LAYOUT_INFLATER_SERVICE</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> ServiceName &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String POWER_SERVICE = <span class="string">"power"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WINDOW_SERVICE = <span class="string">"window"</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LAYOUT_INFLATER_SERVICE = <span class="string">"layout_inflater"</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">getSystemService</span><span class="params">(@ServiceName String name)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Bitmap-并不可怕"><a href="#Bitmap-并不可怕" class="headerlink" title="Bitmap 并不可怕"></a>Bitmap 并不可怕</h3><p>这一章节会介绍一些处理与加载Bitmap对象的常用方法，这些技术能够使得程序的UI不会被阻塞，并且可以避免程序超出内存限制。如果我们不注意这些，Bitmaps会迅速的消耗掉可用内存从而导致程序崩溃，出现下面的异常:java.lang.OutofMemoryError: bitmap size exceeds VM budget.</p><p>在Android应用中加载Bitmaps的操作是需要特别小心处理的，有下面几个方面的原因:</p><ol><li>移动设备的系统资源有限。Android设备对于单个程序至少需要16MB的内存。Android Compatibility Definition Document (CDD), Section 3.7. Virtual Machine Compatibility 中给出了对于不同大小与密度的屏幕的最低内存需求。 应用应该在这个最低内存限制下去优化程序的效率。当然，大多数设备的都有更高的限制需求。</li><li>Bitmap会消耗很多内存，特别是对于类似照片等内容更加丰富的图片。 例如，Galaxy Nexus的照相机能够拍摄2592x1936 pixels (5 MB)的图片。 如果bitmap的图像配置是使用ARGB_8888 (从Android 2.3开始的默认配置) ，那么加载这张照片到内存大约需要19MB(2592<em>1936</em>4 bytes) 的空间，从而迅速消耗掉该应用的剩余内存空间。</li><li>Android应用的UI通常会在一次操作中立即加载许多张bitmaps。 例如在ListView, GridView 与 ViewPager 等控件中通常会需要一次加载许多张bitmaps，而且需要预先加载一些没有在屏幕上显示的内容，为用户滑动的显示做准备。</li></ol><p><a href="http://hukai.me/android-training-course-in-chinese/graphics/displaying-bitmaps/load-bitmap.html" target="_blank" rel="noopener">高效加载大图</a></p><h3 id="善用Service资源"><a href="#善用Service资源" class="headerlink" title="善用Service资源"></a>善用Service资源</h3><p>如果你的应用需要在后台使用service，除非它被触发并执行一个任务，否则其他时候service都应该是停止状态。另外需要注意当这个service完成任务之后因为停止service失败而引起的内存泄漏。</p><p>当你启动一个service，系统会倾向为了保留这个service而一直保留service所在的进程。这使得进程的运行代价很高，因为系统没有办法把service所占用的RAM空间腾出来让给其他组件，另外service还不能被paged out。这减少了系统能够存放到LRU缓存当中的进程数量，它会影响app之间的切换效率。它甚至会导致系统内存使用不稳定，从而无法继续保持住所有目前正在运行的service。</p><p>限制你的service的最好办法是使用IntentService， 它会在处理完交代给它的intent任务之后尽快结束自己。更多信息，请阅读Running in a Background Service.</p><p>当一个Service已经不再需要的时候还继续保留它，这对Android应用的内存管理来说是最糟糕的错误之一。因此千万不要贪婪的使得一个Service持续保留。不仅仅是因为它会使得你的应用因为RAM空间的不足而性能糟糕，还会使得用户发现那些有着常驻后台行为的应用并且可能卸载它。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="http://www.cnblogs.com/vamei/archive/2013/04/28/3048353.html" target="_blank" rel="noopener">http://www.cnblogs.com/vamei/archive/2013/04/28/3048353.html</a></li><li><a href="http://daily.zhihu.com/story/7364069" target="_blank" rel="noopener">http://daily.zhihu.com/story/7364069</a></li><li><a href="http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/" target="_blank" rel="noopener">http://droidyue.com/blog/2014/11/02/note-for-google-io-memory-management-for-android-chinese-edition/</a></li></ol><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2016年03月30日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      定位内存泄露问题，内存抖动问题，ArrayMap优化原理，Bitmap优化原理
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/tags/android/"/>
    
      <category term="memory" scheme="http://www.woaitqs.cc/tags/memory/"/>
    
      <category term="performance" scheme="http://www.woaitqs.cc/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>关于 Volley 的一点思考</title>
    <link href="http://www.woaitqs.cc/2015/04/20/2015-04-20-read-source-code-about-volley/"/>
    <id>http://www.woaitqs.cc/2015/04/20/2015-04-20-read-source-code-about-volley/</id>
    <published>2015-04-20T12:48:09.000Z</published>
    <updated>2019-07-26T14:29:47.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要阅读Volley的源码"><a href="#为什么需要阅读Volley的源码" class="headerlink" title="为什么需要阅读Volley的源码"></a>为什么需要阅读Volley的源码</h2><p>Volley是Google在2013年推出的一个网络库，用于解决复杂网络环境下网络请求问题。「Google出品，必属精品」，而且Volley被使用在包括「Google Plus」的一系列Google产品中，久经考验。因此我们通过学习Volley的源代码，可以学得很多Android网络处理方面的知识，同时可以看看Google 在设计Volley体系结构的时候，所使用的技巧。</p><p><img src="/images/blog/arrow-rain.jpg" alt="在多如箭雨的情形下，Volley是如何帮你搞定一切的"></p><hr><h2 id="Volley组件化的设计"><a href="#Volley组件化的设计" class="headerlink" title="Volley组件化的设计"></a>Volley组件化的设计</h2><p>设计良好的组件，在实现层面上也一定是组件完备的。通过一些基础组件的拼接，来架构起一些伟大的功能。</p><p>对于网络请求而已，相应大多数人，在设计之初开始，会想到外界输入一个网络请求，通过回调的方式给调用相应的反馈就可以了，遵循这样的设计思路下去，在顶向下地设计就会有一个架构设计，但如果出现一些需求的变动，这样的架构能否在较小代价的情况下来满足需求的变动呢？另一方面，如果我们试着自底向上地展开设计了？</p><p>开始先想想对于网络库而已，我们需要什么样的组件。「网络」（负责通过URL和参数来从网络中请求数据），「缓存」（将数据缓存下来，并提供接口供外界请求），「请求」（对请求的封装，比如参数，方法，优先级等），「响应」（对结果的封装），「错误」（请求过程中发生的问题）。这些Volley提出的实现是「Network.java」,「Cache.java」,「Request.java」,「Response.java」，「VolleyError.java」,现在有了这些基础组件后，还剩下2个工作：</p><ol><li>为这些定义的组件提供实现。</li><li>尽可能地为这些组件提供一个统一的入口. 「<a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">外观模式</a>」</li></ol><p>在下面的章节里面，来逐个分析每个组件，最后看看Volley是如何把这些组件联系在一起的。</p><h3 id="Compoment-NetWork"><a href="#Compoment-NetWork" class="headerlink" title="Compoment [NetWork]"></a>Compoment [NetWork]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs the specified request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request Request to process</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A &#123;<span class="doctag">@link</span> NetworkResponse&#125; with data and caching metadata; will never be null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> VolleyError on errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的结构十分明晰，从接收Request输入到提供NetworkResponse输出，在发生异常的时候，抛出VolleyError。这里是对网络请求进行的封装，这与普通的网络请求不一样，因而Volley提供了另一个组件<strong>HttpStack</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，Network是针对HttpStack进行的包装，Volley实现了2种HttpStack，分别针对2.3以下和4.0以上系统。在2.3系统的时候，还没有UrlConnection, 因此用HttpClient来代替。原因可以参考<a href="http://android-developers.blogspot.hk/2011/09/androids-http-clients.html" target="_blank" rel="noopener">这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">        <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">        stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是HttpClientStack还是HUrlStack都是对request.getMethod()里面的几乎所有方法，包括PUT，POST，DELETE，GET四种RestFul风格的。这里指出这个，是想提醒调用者除了Get和POST外，还有其他方法可以调用，同时<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">RestFul</a>风格的API正得到广泛认可。Restful 风格把一切都当做资源，提供增，删，改，查四种方式，Volley是对Restful风格进行了良好的支持。调用方可以通过对Volley进行封装可以实现一个RestFul的RPC client。</p><p>再来看看Network的实现<strong>BasicNetwork</strong>，里面有许多值得学习的地方：</p><ol><li>对etag，和 lastModified 的支持。当我们把一个Response缓存下来的时候，服务端可能返回Etag和lastModified，服务端通过这两个值就可以判断这个请求是否可以命中服务端的缓存，从而可以加快返回的速度。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">    headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entry.lastModified &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Date refTime = <span class="keyword">new</span> Date(entry.lastModified);</span><br><span class="line">    headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>处理 NOT_MODIFIED 的情况。当服务端返回304的时候，即表示命中了缓存，在这里就不需要再走返回Response的步骤了，直接使用Cache中的数据就可以了。在实现上面，是通过Mock的一个NetworkResponse来实现的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Handle cache validation.</span></span><br><span class="line"><span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line"></span><br><span class="line">    Entry entry = request.getCacheEntry();</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, <span class="keyword">null</span>,</span><br><span class="line">                responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">                SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A HTTP 304 response does not have all header fields. We</span></span><br><span class="line">    <span class="comment">// have to use the header fields from the cache entry plus</span></span><br><span class="line">    <span class="comment">// the new ones from the response.</span></span><br><span class="line">    <span class="comment">// http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</span></span><br><span class="line">    entry.responseHeaders.putAll(responseHeaders);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data,</span><br><span class="line">            entry.responseHeaders, <span class="keyword">true</span>,</span><br><span class="line">            SystemClock.elapsedRealtime() - requestStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>获取 Response Contents 的数据。如果responseContents使用了3态，亦即通过null，空和有数据来表示三种状态，这是一种很有意思的编程技巧。重点在于<strong>entityToBytes</strong>方法。 这个方法里面使用了一个字节池，来避免我们每次allocate 一个字节数组的开销。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line"><span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">  <span class="comment">// no-content request.</span></span><br><span class="line">  responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看ByteArrayPool是如何实现的，其实原理很简单，就是用空间来换取性能，避免OOM。在实现上面是使用了「惰性添加」的方式，最大限度的避免在不调用Volley的时候的开销，但也可以根据实际需求，先new出来一个字节数组。</p><p>核心方法是如下2个，分别是 <strong>getBuf</strong> 和 <strong>returnBuf</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] getBuf(<span class="keyword">int</span> len) &#123;</span><br><span class="line"><span class="comment">// 遍历已经分配好了的buffer，然后返回这个，并从数组里面溢出点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mBuffersBySize.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = mBuffersBySize.get(i);</span><br><span class="line">        <span class="keyword">if</span> (buf.length &gt;= len) &#123;</span><br><span class="line">            mCurrentSize -= buf.length;</span><br><span class="line">            mBuffersBySize.remove(i);</span><br><span class="line">            mBuffersByLastUse.remove(buf);</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则新建一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnBuf</span><span class="params">(<span class="keyword">byte</span>[] buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="keyword">null</span> || buf.length &gt; mSizeLimit) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 持有引用，避免被内存回收</span></span><br><span class="line">    mBuffersByLastUse.add(buf);</span><br><span class="line">    <span class="comment">// 二分搜索</span></span><br><span class="line">    <span class="keyword">int</span> pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pos = -pos - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mBuffersBySize.add(pos, buf);</span><br><span class="line">    mCurrentSize += buf.length;</span><br><span class="line">    <span class="comment">// 遍历一下，去掉超出maxSize后最近使用的一个字节数组</span></span><br><span class="line">    trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Compoment-Cache"><a href="#Compoment-Cache" class="headerlink" title="Compoment [Cache]"></a>Compoment [Cache]</h3><p>现在看看Volley是如何实现Cache的，后面再接着分析其他几个组件。Cache里面的核心组件是Entry，这个类封装了Cache的一些细节知识，简单看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The data returned from cache. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** ETag for cache coherency. */</span></span><br><span class="line">    <span class="comment">// etag 和 lastModified 用来向服务器端请求时带上，便于服务器看是否有缓存。</span></span><br><span class="line">    <span class="keyword">public</span> String etag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Date of this response as reported by the server. */</span></span><br><span class="line">    <span class="comment">// 记录这些数据是什么时候从服务器端返回的，从而可以有相对比较复杂的策略。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The last modified date for the requested object. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> lastModified;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** TTL for this record. */</span></span><br><span class="line">    <span class="comment">// Time to Leave 客户端可以通过这个数据来判断当前内容是否过期。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Soft TTL for this record. */</span></span><br><span class="line">    <span class="comment">// 在这个时间内，是否需要刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Immutable response headers as received from server; must be non-null. */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if the entry is expired. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if a refresh is needed from the original data source. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Cache提供的接口里面，除了put和get方法外，还有一个方法是<strong>initialize</strong> 方法，这个在CacheDispatcher启动的时候，会去执行。这里相当于给各种Cache策略，提供了一种在初始化的时候的Hook，通过这个Hook可以实现复杂的策略。</p><p>Volley提供了2种cache方式，一是<strong>NoCache</strong>，而是<strong>DiskBasedCache</strong>，NoCache比较简单，重点看看<strong>DiskBasedCache</strong>。<br>DiskBasedCache 提供了 get 和 remove 方法，便于写入和读取。文件级别的Cache默认最大大小为5M，在初始化的时候，会把内存中的Cache读入到内存中，通过LinkedHashMap来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Magic number for current version of cache file format. */</span></span><br><span class="line"><span class="comment">// 这里有一个魔法数，当在读取值的时候，会去判断是否是与这个魔法值相同，以判断是否为Cache.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_MAGIC = <span class="number">0x20150306</span>;</span><br></pre></td></tr></table></figure><h3 id="Compoment-Request"><a href="#Compoment-Request" class="headerlink" title="Compoment [Request]"></a>Compoment [Request]</h3><p>Request 相当于整个Volley系统的输入，通过Request，建立起与内部系统沟通的桥梁，因此<strong>Request</strong>的设计至关重要。我们来分析下，Request是如何与内部系统建立沟通的。</p><ol><li>如何让Volley知道，我需要什么样的数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure><p>首先Request是支持泛型的，通过这个泛型来定义Request需要什么样的数据，同时volley 提供了这样的方法，来指定调用方如何通过response 来变成自己想要的数据。</p><ol start="2"><li>如何让系统知道我需要优先执行我的任务。Volley通过 Priority 这个来判断优先级，在实际执行里面，是通过 PriorityBlockingQueue 来实现优先级高的队列来执行。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">    LOW,</span><br><span class="line">    NORMAL,</span><br><span class="line">    HIGH,</span><br><span class="line">    <span class="comment">// 目前用于清除Cache</span></span><br><span class="line">    IMMEDIATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如何让 Volley 知道我要怎么去执行任务</li></ol><p>这个是最根本的需求，调用方可以通过url，method等内容与Volley进行交互，传递参数通过getParams()来实现的。这样实现的一个好处在于可以把一些校验逻辑放在子类里面，子类里面可以校验参数是否合法，如果不合法，则抛出AuthFailureError异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a Map of parameters to be used for a POST or PUT request.  Can throw</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AuthFailureError&#125; as authentication may be required to provide these values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that you can directly override &#123;<span class="doctag">@link</span> #getBody()&#125; for custom data.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AuthFailureError in the event of auth failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">getParams</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如何让 Volley 知道我想进行一些操作</li></ol><p>目前volley仅支持 Cancel 操作，当用户想取消某个 request 的时候，实际上是设置了一个标志位，Volley 通过这个标志位来进行判断，以决定后续的操作。</p><h3 id="Compoment-Request-和-Error"><a href="#Compoment-Request-和-Error" class="headerlink" title="Compoment [Request 和 Error]"></a>Compoment [Request 和 Error]</h3><p>Response 和 Error 就是Volley 对调用方的输出，在经历对调用方屏蔽内部细节过后，将Response 告诉调用者。Error 就是对 Exception 的简单封装，这里也就不细细描述了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Callback interface for delivering parsed responses. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Called when a response is received. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Callback interface for delivering error responses. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Callback method that an error has been occurred with the</span></span><br><span class="line"><span class="comment">     * provided error code and optional user-readable message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Volley-的其他细节"><a href="#Volley-的其他细节" class="headerlink" title="Volley 的其他细节"></a>Volley 的其他细节</h2><p><img src="http://img.blog.csdn.net/20130702124824156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdDEyeDM0NTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Volley 体系结构"></p><p>在Volley 的结构里面，组件都已经定义完毕了，剩下的工作就是如何把这些组件以合适的方式组合起来，供调用者使用。</p><h3 id="RequestQueue的外观模式"><a href="#RequestQueue的外观模式" class="headerlink" title="RequestQueue的外观模式"></a>RequestQueue的外观模式</h3><p>RequestQueue 封装了 Request 队列的一系列操作，理论上用户知道RequestQueue就足够了，通过这个队列来进行任务的添加和取消，当Request 结束的时候，给调用者相应的回调即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里无需去管是否马上stop成功，因为线程引用已经被修改了</span></span><br><span class="line">        stop();  <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">        <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">        mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">        <span class="comment">// 启动Cache dispatcher</span></span><br><span class="line">        mCacheDispatcher.start();</span><br><span class="line">        <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">        <span class="comment">// 启动network dispatcher</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CacheDispatcher-amp-NetworkDispatcher"><a href="#CacheDispatcher-amp-NetworkDispatcher" class="headerlink" title="CacheDispatcher &amp; NetworkDispatcher"></a>CacheDispatcher &amp; NetworkDispatcher</h3><p>仔细想想，Volley 其实是一个生产者和消费者系统，调用方是生产者，而Volley是消费者。调用方通过RequestQueue 生产Request，而Vollery 消费Request 从而得到Response。那么负责调配这些生产者和消费者的就是Dispatcher，分别是Cache 和 Network 的Dispatcher。</p><p>Dispatcher 在实现上，其实比较简单。首先Dispatcher是Thread，线程的Run方法里面，是一个While循环，Run方法在开始的时候，会去读取Request，读取不到会一直Block在哪里；在读取完成后，就开始走相应的逻辑，比如写入缓存或者从网络中读取数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">    mCache.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">            <span class="comment">// at least one is available.</span></span><br><span class="line">            <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">            request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the request has been canceled, don't bother dispatching it.</span></span><br><span class="line">            <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Attempt to retrieve this item from cache.</span></span><br><span class="line">            Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                <span class="comment">// Cache miss; send off to the network dispatcher.</span></span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If it is completely expired, just send it to the network.</span></span><br><span class="line">            <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We have a cache hit; parse its data for delivery back to the request.</span></span><br><span class="line">            request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">            Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                    <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                <span class="comment">// Completely unexpired cache hit. Just deliver the response.</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Soft-expired cache hit. We can deliver the cached response,</span></span><br><span class="line">                <span class="comment">// but we need to also send the request to the network for</span></span><br><span class="line">                <span class="comment">// refreshing.</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">                response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mNetworkQueue.put(request);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2015年04月20日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      从源码入手，从设计出发，详细说明 volley 是如何实现的
    
    </summary>
    
    
      <category term="android" scheme="http://www.woaitqs.cc/categories/android/"/>
    
    
      <category term="volley" scheme="http://www.woaitqs.cc/tags/volley/"/>
    
      <category term="android" scheme="http://www.woaitqs.cc/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap 源码解析终极版</title>
    <link href="http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/"/>
    <id>http://www.woaitqs.cc/2015/04/14/2015-04-14-read-source-code-about-hashmap/</id>
    <published>2015-04-14T08:52:50.000Z</published>
    <updated>2019-07-26T14:14:59.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>ConCurrentHashMap 是一个被忽视的Java Concurrent包下面的类，在满足并发的「安全性」，和「活跃性」的前提下，做到了与不考虑线程安全的 HashMap 同等效率. 作者是大名鼎鼎的<a href="http://en.wikipedia.org/wiki/Doug_Lea" target="_blank" rel="noopener">Doug Lea</a>，他老人家在Java 并发领域做的贡献，确实是我们的榜样。下篇文章，对ConCurrentHashMap做一个分析，希望这个代码中的闪光点，能够对各位读者产生启发。这里先介绍HashMap做的实现，便于后面我们理解2者的差异，以及[Doug Lea]完成的ConCurrentHashMap类具有那些惊为天人的地方。</p><hr><h2 id="JDK-是如何定义Map接口的"><a href="#JDK-是如何定义Map接口的" class="headerlink" title="JDK 是如何定义Map接口的"></a>JDK 是如何定义Map接口的</h2><p>在设计一个通用的模块和功能的时候，我们需要静下心来分析下根本需求是什么？根据这个需求来理清我们的思路。</p><p>Map，就是Key-Value对，通过Key可以快速找到对应的Value，核心的需求是Put和Get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K,V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K)</span></span>;</span><br></pre></td></tr></table></figure><p>在实际的需求里面，虽然不同于Collection，但是一些基础功能和需求是共通的，所以需要额外地加上一些基础方法，比如<code>isEmpty()</code>,<code>size()</code>等。于是而后在原来的基础上添加了其他基础抽象，最后形成的接口大体可以如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在这个时候，可能会有2个问题</p><p>1）为什么Map接口没有继承自Collection?</p><p>这个在JDK的问题里面所说的是Map，和Collection根本是两个东西，具体可以参考下面的引用</p><blockquote><p>This was by design. We feel that mappings are not collections and collections are not mappings. Thus, it makes little sense for Map to extend the Collection interface (or vice versa).<br>If a Map is a Collection, what are the elements? The only reasonable answer is “Key-value pairs”, but this provides a very limited (and not particularly useful) Map abstraction. You can’t ask what value a given key maps to, nor can you delete the entry for a given key without knowing what value it maps to.<br>Collection could be made to extend Map, but this raises the question: what are the keys? There’s no really satisfactory answer, and forcing one leads to an unnatural interface.<br>Maps can be viewed as Collections (of keys, values, or pairs), and this fact is reflected in the three “Collection view operations” on Maps (keySet, entrySet, and values). While it is, in principle, possible to view a List as a Map mapping indices to elements, this has the nasty property that deleting an element from the List changes the Key associated with every element before the deleted element. That’s why we don’t have a map view operation on Lists.</p></blockquote><p>Map可以用Collection来实现，但不一定意味着Map就一定是Collection，Collecton也不一定是Map。</p><p>2）为什么没有实现Iterator接口？</p><p>Map在定义上面就没有要求一定是可以迭代的，有人可能疑问用EntrySet来实现迭代啊？但是从设计的角度上去理解，如果用EntrySet的方式在接口里面申明Iterator接口，就意味着把内部的实现细节暴露出去了。所以宁愿提供 <code>entrySet()</code> 的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a &#123;<span class="doctag">@code</span> Set&#125; containing all of the mappings in this &#123;<span class="doctag">@code</span> Map&#125;. Each mapping is</span></span><br><span class="line"><span class="comment"> * an instance of &#123;<span class="doctag">@link</span> Map.Entry&#125;. As the &#123;<span class="doctag">@code</span> Set&#125; is backed by this &#123;<span class="doctag">@code</span> Map&#125;,</span></span><br><span class="line"><span class="comment"> * changes in one will be reflected in the other.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a set of the mappings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure><hr><h2 id="HashMap-基础单元"><a href="#HashMap-基础单元" class="headerlink" title="HashMap 基础单元"></a>HashMap 基础单元</h2><p>HashMap作为我们经常用的类，几乎没有程序猿不熟悉Map的用法, 没有道理不去熟悉下HashMap的实现原理。</p><p>HashMap使用java提供的基础类型中的数组，用 <em>HashMapEntry&lt;K, V&gt;[] table</em> 来进行Key-Value键值对的存储。Hash需要完成的工作即是将Key通过Hash的算法，将Key hash到某一个小于数组长度的数值 <em>i</em> 上面，从而在这个位置 <em>i</em> 记录下对应的Value，亦即<code>table[i] = value</code>，这样调用者在调用<code>get(key)</code>方法时，先通过hash计算出i，调用<code>table[i]</code>可以迅速找到相应的Value，这是HashMap查询速度快的原因。</p><p>JDK首先构建了对基础单元的抽象-<code>HashMapEntry</code>，里面的核心成员变量如下代码，其中hash值一个用于缓存，便于进行比较，而next字段则实现了C++的指针，通过这个指针可以链式地找到下一位。这个链式结构的设计目的是为了解决Hash冲突的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;</span><br><span class="line">V value;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">HashMapEntry&lt;K, V&gt; next;</span><br></pre></td></tr></table></figure><hr><h2 id="HashMap-如何避免冲突和解决冲突的"><a href="#HashMap-如何避免冲突和解决冲突的" class="headerlink" title="HashMap 如何避免冲突和解决冲突的"></a>HashMap 如何避免冲突和解决冲突的</h2><p>当两个Key同时hash到一个值时，就会出现这样的冲突。这个冲突主要有2种解决方法。</p><ol><li>开放地址，亦即如果hash冲突，则在空闲的位置进行插入</li><li>hash复用，同一个hash值，链式地加入多个value</li></ol><p>HashMap 选择了第二种方式来解决冲突的问题，注意在 1.6 和 1.7 版本中，Java 对链式存储做了一些优化。如果链表的长度大于 8 个，就不再使用链表，而是采用红黑树，避免一些极限情况下的效率问题。</p><p>整个HashMap的核心部分是hash方法，我们先从最核心的方法看起，HashMap 是如何实现将hashCode值映射到table数组里面的索引里面的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> putValueForNullKey(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; e = tab[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">            preModify(e);</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No entry for (non-null) key is present; create one</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt; threshold) &#123;</span><br><span class="line">        tab = doubleCapacity();</span><br><span class="line">        index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addNewEntry(key, value, hash, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.secondaryHash(key)方法里面使用了</span></span><br><span class="line"><span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在这里面可以看到Hash的代码主要是Wang/Jenkins hash方法，这个方法具有两个属性</p><ol><li>雪崩性（更改输入参数的任何一位，就将引起输出有一半以上的位发生变化）</li><li>可逆性（input ==&gt; hash ==&gt; inverse_hash ==&gt; input）</li></ol><p>Collections.secondaryHash能够使得hash过后的值的分布更加均匀，尽可能地避免冲突，<a href="http://burtleburtle.net/bob/hash/integer.html" target="_blank" rel="noopener">具体原理点连接</a>，注意这里的前提是table的长度为2的幂次方，从构造函数对capacity的改造可以看出来。<code>hash &amp; (tab.length - 1)</code> 当tab.length为2^n-1的时候，可以保证结果不大于tab.length。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MINIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = Collections.roundUpToPowerOfTwo(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    makeTable(capacity);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举一个例子，如果现在Table的容量是16，如果最后的结果是 <strong>hash &amp; (16-1)</strong>，也就是 <strong>hash &amp; (00001111)</strong>。现在我们试着对hash值是31(00011111), 63(00111111),95(01011111)进行操作，理论上映射到的index值应该是不尽相同的，然而实际的情况确实如下的情形：</p><p>31=00011111 ==&amp; 00001111==&gt; 1111=15</p><p>63=00111111 ==&amp; 00001111==&gt; 1111=15</p><p>95=01011111 ==&amp; 00001111==&gt; 1111=15</p><p>因此Collections.secondaryHash需要解决的问题，就是避免上面的情况，效果见下面的例子：</p><p>31=00011111 ==secondaryHash==&gt; 00011110==&amp; 00001110==&gt; 14</p><p>63=00111111 ==secondaryHash==&gt; 00111100==&amp; 00001100==&gt; 12</p><p>95=01011111 ==secondaryHash==&gt; 01011010==&amp; 00001010==&gt; 10</p><hr><h2 id="HashMap-如何解决容量不足的问题"><a href="#HashMap-如何解决容量不足的问题" class="headerlink" title="HashMap 如何解决容量不足的问题"></a>HashMap 如何解决容量不足的问题</h2><p>前面解决了hash冲突的问题，那么现在如何解决容量不足的问题了。考虑这样的情况，如果用户大量地调用put方法，在这种情况下，如果容量不变，那么势必会出现大量的冲突，调用get方法时，可能需要很长长度的遍历才能得到答案，性能损失严重，因此，我们可以发现源码中有这样一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size++ &gt; threshold) &#123;</span><br><span class="line">tab = doubleCapacity();</span><br><span class="line">index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK给出的方案是扩容，doubleCapacity()方法，比如原来容量为16，当现在的使用量大于 DEFAULT_LOAD_FACTOR X Capacity，下次直接把容量扩展到32.<br>这段代码注解说的是这整个类的精华，我们必须好好研究下.</p><blockquote><blockquote><p>Rehash the bucket using the minimum number of field writes, and this is the most subtle and delicate code in the class.</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Doubles the capacity of the hash table. Existing entries are placed in</span></span><br><span class="line"><span class="comment"> * the correct bucket on the enlarged table. If the current capacity is,</span></span><br><span class="line"><span class="comment"> * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which</span></span><br><span class="line"><span class="comment"> * will be new unless we were already at MAXIMUM_CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> HashMapEntry&lt;K, V&gt;[] doubleCapacity() &#123;</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="keyword">return</span> oldTable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span>;</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCapacity; j++) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Rehash the bucket using the minimum number of field writes.</span></span><br><span class="line"><span class="comment">         * This is the most subtle and delicate code in the class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMapEntry&lt;K, V&gt; e = oldTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> highBit = e.hash &amp; oldCapacity;</span><br><span class="line">        HashMapEntry&lt;K, V&gt; broken = <span class="keyword">null</span>;</span><br><span class="line">        newTable[j | highBit] = e;</span><br><span class="line">        <span class="keyword">for</span> (HashMapEntry&lt;K, V&gt; n = e.next; n != <span class="keyword">null</span>; e = n, n = n.next) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextHighBit = n.hash &amp; oldCapacity;</span><br><span class="line">            <span class="keyword">if</span> (nextHighBit != highBit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (broken == <span class="keyword">null</span>)</span><br><span class="line">                    newTable[j | nextHighBit] = n;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    broken.next = n;</span><br><span class="line">                broken = e;</span><br><span class="line">                highBit = nextHighBit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (broken != <span class="keyword">null</span>)</span><br><span class="line">            broken.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们注意其中这部分的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> highBit = e.hash &amp; oldCapacity;</span><br><span class="line">newTable[j | highBit] = e;</span><br></pre></td></tr></table></figure><p>我们现在来说明，oldCapacity假设为16(00010000), <strong>int highBit = e.hash &amp; oldCapacity</strong> 能够得到高位的值，因为低位全为0，经过与操作过后，低位一定是0。J 在这里是index，J 与 高位的值进行与操作过后，就能得到在扩容后面的新的index值。</p><p>设想一下，理论上我们得到的新的值应该是 <code>newValue = hash &amp; (newCapacity - 1)</code> ，与 <code>oldValue = hash &amp; (oldCapacity - 1)</code> 的区别仅在于高位上。 因此我们用 <code>J | highBit</code> 就可以得到新的index值。</p><hr><h2 id="HashMap-是如何解决迭代问题"><a href="#HashMap-是如何解决迭代问题" class="headerlink" title="HashMap 是如何解决迭代问题"></a>HashMap 是如何解决迭代问题</h2><p>首先HashMap提供了3种形式的迭代方法，分别是针对Entry，Key和Value的迭代器，这里实现的代码就比较简单，看下具体的例子就可以知道。实现方式主要是依赖于对HashEntity数组进行遍历即可实现。</p><p>问题在于如何保证迭代的时候，基于正确的输出，聪明的你一定看出来了，难度在于「多线程情况的处理」。在迭代的时候，外部可以通过调用put和remove的方法，来改变正在迭代的对象。但从设计之处，HashMap自身就不是线程安全的，因此HashMap在迭代的时候使用了一种Fast—Fail的实现方式，在HashIterator里面维持了一个 expectedModCount 的变量，在每次调用的时候如果发现 <code>ModCount != expectedModCount</code>，则抛出 ConcurrentModificationException 异常。但本身这种检验不能保证在发生错误的情况下，一定能抛出异常，所以我们需要在使用HashMap的时候，心里知道这是「非线程安全」的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashMapEntry&lt;K, V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (nextEntry == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    HashMapEntry&lt;K, V&gt; entryToReturn = nextEntry;</span><br><span class="line">    HashMapEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">    HashMapEntry&lt;K, V&gt; next = entryToReturn.next;</span><br><span class="line">    <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) &#123;</span><br><span class="line">        next = tab[nextIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">    nextEntry = next;</span><br><span class="line">    <span class="keyword">return</span> lastEntryReturned = entryToReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="HashMap-是如何实现序列化接口的"><a href="#HashMap-是如何实现序列化接口的" class="headerlink" title="HashMap 是如何实现序列化接口的"></a>HashMap 是如何实现序列化接口的</h2><p>HashMap是实现了Serializable接口的，这种Hash的结构如何实现序列化？按照最朴素的想法，按照默认的实现即可，但是细想之下，一个16位的数组如果只存了一个数据，却要把16位的数组到序列化进去，这本身并不可取。于是HashMap 将其他数据申明为transient，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>避免这些常量参与到序列化的细节里面去，在另一方面重写 <strong>writeObject()</strong> 和 <strong>readObject()</strong> 方法，通过这样的方式来实现序列化，在代码里面添加了注释，便于大家理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Emulate loadFactor field for other implementations to read</span></span><br><span class="line">    ObjectOutputStream.PutField fields = stream.putFields();</span><br><span class="line">    fields.put(<span class="string">"loadFactor"</span>, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    stream.writeFields();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入table的容量</span></span><br><span class="line">    stream.writeInt(table.length); <span class="comment">// Capacity</span></span><br><span class="line">    <span class="comment">// 写入目前的Entry数量</span></span><br><span class="line">    stream.writeInt(size);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) &#123;</span><br><span class="line">    <span class="comment">// 迭代地写入Key和Value</span></span><br><span class="line">        stream.writeObject(e.getKey());</span><br><span class="line">        stream.writeObject(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">    stream.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> capacity = stream.readInt();</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Capacity: "</span> + capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MINIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capacity &gt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        capacity = MAXIMUM_CAPACITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        capacity = Collections.roundUpToPowerOfTwo(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    makeTable(capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到size大小</span></span><br><span class="line">    <span class="keyword">int</span> size = stream.readInt();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Size: "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(); <span class="comment">// Give subclass (LinkedHashMap) a chance to initialize itself</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) K key = (K) stream.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V val = (V) stream.readObject();</span><br><span class="line">        <span class="comment">// 构造函数里面，会计算hash放置到响应的地方</span></span><br><span class="line">        constructorPut(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2018年11月10日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      Source code about HashMap, hashmap 源码详细说明
    
    </summary>
    
    
      <category term="program" scheme="http://www.woaitqs.cc/categories/program/"/>
    
    
      <category term="java" scheme="http://www.woaitqs.cc/tags/java/"/>
    
      <category term="program" scheme="http://www.woaitqs.cc/tags/program/"/>
    
      <category term="hashmap" scheme="http://www.woaitqs.cc/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>读薄《你的灯还亮着吗？》</title>
    <link href="http://www.woaitqs.cc/2015/01/05/2015-01-05-how-to-solve-problem/"/>
    <id>http://www.woaitqs.cc/2015/01/05/2015-01-05-how-to-solve-problem/</id>
    <published>2015-01-05T08:52:50.000Z</published>
    <updated>2019-07-26T14:09:37.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>问题太多了，实在太多了。</p><p>这是大多数项目开发里面遇到的情形，好不容易翻山越岭地解决了一个Bug，结果冒出另一连串Bug（不要和我谈OO，GOF这些的）。不只是项目里面，人生简直就是用来和问题搏斗的，打完一个小问题Boss，迎面的而来是大问题Boss。</p><p>如果所有问题都有一套解决方案来应对，这个世界会幸福好多。可这是妄想，问题太复杂，根本不可能完全解决，也不会有一个通用的方案（各位读者不要按<code>「Ctrl+W」</code>）。</p><p>近来略微闲下来，也仔细想想「问题」这个复杂的问题。得出一些有意思的看法，和大家分享。</p><hr><h2 id="问题是什么"><a href="#问题是什么" class="headerlink" title="问题是什么"></a>问题是什么</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一花一世界，一叶一如来，春来花自青，秋至叶飘零，无穷般若心自在，语默动静以自然。</span><br></pre></td></tr></table></figure><p>问题是<code>「理想世界与现实世界的差异」</code>的心理学定义</p><p>问题真的只是一种<code>「心理学定义」</code>，你觉得这是问题，那么它就是问题，你不觉得他是问题，那么它就不是问题。听起来挺玄乎的，可这就是一个感受问题。隔壁搬砖王老五早起发现自己的波斯猫丢了，吓得下巴掉到了地上，你却不屑地走过，“这个死娘炮”！王老五的问题对你而言就不是问题。<br>问题也是一种差距，理想情况下你是王思聪，所以买房，泡妞，放浪形骸这些都不是问题，可你现实里面只是一个上班的白领，所以买房，泡妞，放浪形骸这些都是你要面对的问题。</p><p>理解了这个过后，可以适当地调节下自己的心理预期，好多问题就不是问题了。不去想明天双色球就中个超级大奖，那么就不会把当下的两张彩票当做问题了。这些问题都是佛说的<code>「妄念」</code>。</p><hr><h2 id="我们面对的问题是什么"><a href="#我们面对的问题是什么" class="headerlink" title="我们面对的问题是什么"></a>我们面对的问题是什么</h2><p>除去妄念，剩下来的都是实实在在的「问题」。这些围绕在身边，让人心里有落差的烦心事到底是什么？</p><p>想要很好地定义一个问题，这几乎是办不到的事情，所以我没法回答副标题里面的问题「我们面对的问题是什么？」这里可以通过一个简单的事情来说明一下。写程序时，避免不了Bug的出现，解决Bug常是让程序员头痛的问题。有一个Android项目里面需要使用Blur的效果，于是在Github上搬砖下来一个BlurImage项目的例子，顺利地完成了产品狗的需求，Blur效果上线后，问题接踵而至，OutOfMemory Exception总是时不时地可以在堆栈里面发现。「如何避免OutOfMemory？」就成了一个挡在眼前的问题。在发现CP妹纸配的图片里面有2张是1024*456后，当时就怒了，“你难道不懂Android的内存很局限吗？”，想当然地以为问题是「CP如何保证图片大小合适？」。问题过了一段时间后，OutOfMemory真的减少了不少，更加确认了问题就是「CP如何保证图片大小合适？」。直到一个偶然的机会，我才知道真实的问题是「运维这边的Bug导致图片的压缩服务没Work」，运维修复这个bug后，OutOfMemory自然而然就少了，当然也许事实还不一定是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使问题已经解决，你依然无法确认问题的定义是否正确。</span><br><span class="line">定义问题是很困难的事情，但别停下寻找真相的脚步。特别是Programmer，对于真相的探求是进步的阶梯，而且这关乎我们的职业道德。</span><br></pre></td></tr></table></figure><p>问题一定与人有关的，只与物相关的那叫客观规律。而问题对于不同人而言又不是相同的，因而这里要将「问题是什么」，定义为「我们的问题是什么？」。公司最近开始运营班车，而某些职员住的比较远，从班车运营的费用而言，对这些部分员工专门开通班车是不太现实的。这个时候对于公司和职员而言问题就是不一样的。公司的问题是「如何设计合理的线路，让这些住的远的人在合适的地点搭上其他班车？」，职员的问题则是「如何住得近点？」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个人的问题都不一样，但我们可以换位思考。</span><br></pre></td></tr></table></figure><p>这样看来，我们需要重视解决的主要还是「第一印象」？问题追溯起来，可能太负责，在大多数情况下，我们需要针对这「第一印象」提出解决方法。</p><hr><h2 id="怎么解决问题？"><a href="#怎么解决问题？" class="headerlink" title="怎么解决问题？"></a>怎么解决问题？</h2><p>在心惊胆战地尝试定义问题后，如何来解决这些问题了？没有统一的公式来应对，但可以提供一些角度来思考日常问题的解决。首先问问自己是否需要解决这个问题，谁来解决这个问题？</p><h3 id="谁来解决问题？"><a href="#谁来解决问题？" class="headerlink" title="谁来解决问题？"></a>谁来解决问题？</h3><p>某班级由11个学生组成，他们每周三下午上3小时课，讨论问题的解决方法，而且老师是个聪明人。尽管12个人中有11个不抽烟，剩下的那个人却有严重的雪茄瘾，这让大家错愕不已。教室很小，通风不畅。那位学生的雪茄烟虽然廉价，但烟雾扩散得非常快。第一次上课时，刚上完第一节课，烟气就已经布满了整个空间，只有最矮的学生幸免于难，几个高个子的脸都已经变绿了。而吸烟的同学还在一脸幸福地吞云吐雾，完全没有意识到有任何问题。老师是个问题解决者，在他看来，显然出现了问题，或者说问题很快会出现。</p><p>如何解决这个问题？按照一般的思路下去，大抵的解决方案是“开掉抽雪茄的学生？”。显然一般思路下去，我们会按照老师的角度做下去，提出类似于惩罚抽雪茄学生的方法。思考下「谁来解决这个问题？」。也许更好的方案应该有那些参与的学生来提出。事实上，最后的解决方案是 – “抽雪茄的同学是因为和同学之间无交集，无聊才抽烟的。于是大家决定，每天有一个同学带零食给大家吃，边吃边分享，大家团结过后，自然就不会有这个问题了”。</p><p>在寻找方法来解决问题时，切记提醒自己，「有没有更合适的问题解决者」？</p><h3 id="需要解决吗？"><a href="#需要解决吗？" class="headerlink" title="需要解决吗？"></a>需要解决吗？</h3><p>不需要把力气都放在与世界为敌？那样太累。<br>有些事情，可能不需要解决，就像没必要拼上老命去当个公务员。在职场里面，潜下心来思考下老板让你做这个事情是为了什么？以前就听说过一个例子，老周是一个很牛的员工，但是他所在的公司又没有适合他的岗位，所以公司就给他开了较高的薪水让他去完成一些复杂的事务，其实老板和老周都知道，这些事情没必要解决。生命太宝贵了，就只一次，那些没必要的问题真没必要去解决。</p><h3 id="发现问题的所在"><a href="#发现问题的所在" class="headerlink" title="发现问题的所在"></a>发现问题的所在</h3><p>解决问题难，「提前发现问题更难」。三国演义里面的蒋干（事实上是一个有名的才子）自以为成功说服周瑜，可实际问题是「他被骗了」。我们往往醉心于解决了某某问题，却忽略了可能带来的问题，热衷于线程带来方便，忽视了程序的碎片化。当发现问题后，问题往往可以得到解决，在覆水难收之前发现问题才是最难的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看看你对问题的理解，如果想不出至少3个可能有出错的地方，你就没有真正理解这个问题。</span><br></pre></td></tr></table></figure><p>似乎这样的难题没有有效的方法，但有两个建议。「常换位」和「常回顾」。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每每站在不同的角度上去思考问题，总会发现不协调的地方。</span><br><span class="line">我们在不断前行的路上，常回头看看，有没有不对劲的地方。</span><br></pre></td></tr></table></figure><h3 id="怎么解决问题"><a href="#怎么解决问题" class="headerlink" title="怎么解决问题"></a>怎么解决问题</h3><p>具体到解决问题时，却没有什么可以可说的了，毕竟这是一个领域性极度耦合的事情。<br>个人有愚见，可以沿着这条思路一路下去：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">「需要解决吗？」 -》</span><br><span class="line">「谁来解决？」-》</span><br><span class="line">「不管和自己有没有关系，请尝试思考如果和自己有关系？」 -》</span><br><span class="line">「换个位置想想？」-》</span><br><span class="line">「解决问题」-》</span><br><span class="line">「回顾以上」</span><br></pre></td></tr></table></figure></code></pre><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2015年1月5日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/atom.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      问题是什么？如何解决问题
    
    </summary>
    
    
      <category term="life" scheme="http://www.woaitqs.cc/categories/life/"/>
    
    
      <category term="life" scheme="http://www.woaitqs.cc/tags/life/"/>
    
      <category term="problem" scheme="http://www.woaitqs.cc/tags/problem/"/>
    
  </entry>
  
  <entry>
    <title>贫穷能教会你什么？</title>
    <link href="http://www.woaitqs.cc/2013/11/09/2013-11-09-make-life-better/"/>
    <id>http://www.woaitqs.cc/2013/11/09/2013-11-09-make-life-better/</id>
    <published>2013-11-09T08:52:50.000Z</published>
    <updated>2019-07-26T14:04:22.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不算好过的小时候"><a href="#不算好过的小时候" class="headerlink" title="不算好过的小时候"></a>不算好过的小时候</h2><p>小时候日子真不算太好过，算半个颠沛流离的人，东来西往(<em>湖北-重庆</em>)的。我出生在湖北公安，隶属于荆州的一个小县城，破旧繁杂的典型性村镇，就好像多年后我再回到故乡，还觉得是当年的哪些模样。出生的那几年，村里闹<a href="http://www.baidu.com" target="_blank" rel="noopener">血吸虫</a>，很多人死去，索性我能躲过一劫。父亲在村里经营一个酒厂，收益不是很好，母亲也就回到<code>万州</code>另谋营生。后来听老一辈的人讲，父亲常喝酒，喝得很醉，然后教我数学，现在我的数学符号多半是东倒西歪的，有些酒的风骨在。</p><p>9年后，在一个雨夜父亲和我一起坐床到了万州。在到万州前我对很多事情印象不是很深，而在次之后大部分事情都隐隐有印象了。问过一个学心理的同学，他说人在经历变动或者其他什么重大事情后才开始慢慢记事，挺有道理的。那天雨下的很大，大到我觉得快有洪水到来了，母亲抱着我在哭，和外面的雨水很像，而我和母亲还不熟只是觉得很奇怪。</p><p>在某小学上课的日子，我记得很清楚，某些同学的名字我还记得，虽然毕业后就不再记得。我是属于受欺负的那一类，受人排挤和愚弄，没有太抑郁是想我的聪明才智足以蔑视这一切。印象最深的事情确实我莫名其妙地跟着一帮同学来看一场比赛，黄色衣服的人和红色衣服的人围着一个球提来提前，周围的人也在叫也在吼，那时我知道了两件事情，<code>电视</code>和<code>世界杯</code>(中国对巴西 0-4 惨败)。电视是个好东西，而且是个很神奇的东西，长跑到其他人家门口看电视(<em>直到初中家里才有一个电视，还用了8年时间</em>)，是个武侠剧。对生活中很多事情都是第一次，某年除夕，邻居家的小孩用<code>冲天炮</code>放烟火，映得天空通红通红，我一直朝着天空看着，一直安静地看着。</p><hr><h2 id="贫穷毁了你"><a href="#贫穷毁了你" class="headerlink" title="贫穷毁了你"></a>贫穷毁了你</h2><p>童年是过得不算好，真算贫瘠吧。贫穷教会我什么？还是毁了我？</p><ul><li><p><code>物质</code>。你越缺少什么，这种东西就越可能毁了你。那年头没有电视机，到初中后有了第一台电视，以后初中的每一个周末我都是在电视机旁度过的。电视的内容是重复且无味的，可就是放不下，好像刻在你骨子里的样子。同样比如金钱，你越缺钱就可能越像要钱，这样循环下去，吝啬的你就大抵有了样子，花每一分钱都需要想好几分钟，在几百块的工资和更大的发展空间前也要犹豫半天。那是生下来，拿不走的对穷困日子的恐惧。我母亲会督促我多赚钱，让我在赚钱和上课之间选，她们会选择上课，但也喜欢我多赚钱(即使她们知道这会很累)。贫瘠没有尊严的生活在这个时候会丧失理智，以后都很难摆脱物质。</p></li><li><p><code>远见</code>。比起物质，这更可能毁了你。我们有更多事情需要考虑，有更多东西需要周旋。比起<code>高富帅，白富美</code>，我们活着就是很大的努力了。我们没有足够的机会去接触世界，感受脉搏性的东西，很容易短见，看不清世界的走势。为了几颗白菜，确丢失了大片森林，这些终于会毁掉人。好些人没有读多少书，就远去其他地方打工，不管往后日子怎样，能赚多少钱，他们中真的很多人不会为改变这世界，成就多大的未来。<code>远见</code>这东西，在没物质的年代，只有父母能帮你了。</p></li><li><p><code>心态</code>。心态，畸形的心态。我们迫切渴望，我们迫切努力，我们奋斗，我们哭泣，最后找不到自己。即使明白名利对生活不是最重要，我们更可能为了这些放弃很多去拼去冲，不管多大代价。听上去，好像是很好的事情，只是你仔细想想，你丢了更多东西。我们看不到摄入眼睛的月光，听不到吹过耳畔的风。</p></li></ul><hr><h2 id="那么完蛋了吗？"><a href="#那么完蛋了吗？" class="headerlink" title="那么完蛋了吗？"></a>那么完蛋了吗？</h2><p>不，我有足以生活的<code>物质</code>，有立足未来的<code>父亲</code>，有可以依赖和信赖的<code>心态</code>。<br>仅以此文，献给我的父亲和我自己，感谢贫穷日子里，给我一盏灯。</p><hr><h2 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h2><ul><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</li><li>发表日期：2013年11月09日</li><li>社交媒体：<a href="http://weibo.com/woaitqs" target="_blank" rel="noopener">weibo.com/woaitqs</a></li><li>Feed订阅：<a href="http://www.woaitqs.cc/feed.xml">www.woaitqs.cc/feed.xml</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      对贫穷的深刻反思
    
    </summary>
    
    
      <category term="life" scheme="http://www.woaitqs.cc/categories/life/"/>
    
    
      <category term="life" scheme="http://www.woaitqs.cc/tags/life/"/>
    
      <category term="think" scheme="http://www.woaitqs.cc/tags/think/"/>
    
  </entry>
  
</feed>
